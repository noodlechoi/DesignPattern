###### [헤드 퍼스트 패턴 깃허브](https://github.com/IT-Book-Organization/HeadFirst-DesignPattern)
* * *
Chapter 1. 전략 패턴
=========
### 객체지향 기초
  - 추상화
  - 캡슐화
  - 다형성
  - 상속
### 객체지향 원칙
  - 바뀌는 부분은 캡슐화
  - 상속보다는 구성
  - 구현보다 인터페이스에 포커싱
### 전략 패턴이란?
  - 알고리즘군을 정의하고 캡슐화해서 각각의  알고리즘군을 수정해서 쓸 수 있게 해주는 디자인 패턴.
### 생각해보기
  - 나중에 어떻게 바뀔 것인가? (재사용성, 확장성, 관리 용이성)
* * *
#### 과제
  - 오리 코드 테스트 C++로 바꿔보기 [완료](https://github.com/noodlechoi/DesignPattern/tree/main/Practice/Chapter1)
  - 인터페이스 vs 추상 클래스 차이 정리
    + 인터페이스는 상태나 구현을 가질 수 없지만, 추상 클래스는 가질 수 있다.
    + [링크](https://velog.io/@hyongti/C%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs.-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%ED%81%B4%EB%9E%98%EC%8A%A4)
  - 낱말 퀴즈 풀기


Chapter 2.  옵저버 패턴
=========
### 옵저버 패턴이란?
  - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다. 신문사와 구독자 관계와 유사하다.
### 느슨한 결합(Loose Coupling)
  - 객체 끼리 상호작용할 수는 있지만, 서로를 잘 모르는 관계를 의미
  - 유연성이 좋아진다.
### 생각해보기
  - 측정치를 직접 전달하는 방법 말고 갱신된 상태를 옵저버에게 전달하는 다른 접근법은 무엇이 있을지? 답: update의 인자를 없애고 getter로 값을 받는다.
* * *
#### 과제
  - 기상 스테이션 코드 C++로 구현 [완료](https://github.com/noodlechoi/DesignPattern/tree/main/Practice/Chapter2)


Chapter 3.  데코레이터 패턴
=========
### OCP(Open-Closed Principle)
  - 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야한다는 디자인 원칙
  - 무조건 적용한다면 시간 낭비를 하거나 복잡하고 이해하기 힘든 코드를 만들게 될 수 있다.
  - 기존 코드는 건들지 않고 확장으로 새로운 동작 추가하기
  - **준수 방법**: 가장 바뀔 가능성이 높은 부분을 중점적으로 살펴보고 적용한다.
### 데코레이터 패턴이란?
  - 동적으로 추가 요소를 더할 수 있도록 하는 디자인 패턴이다.
  - 구상 구성 요소를 감싸 주는 데코레이터를 사용
  - 구성 요소의 클라이언트는 데코레이터의 존재를 알 수 없다.
  - 상속으로 행동을 물려받는 것이 아니라 형식을 맞추는 것이다.
    + 형식을 맞추는 이유: 구성 요소에 자신이 들어가야하기 때문이다.
    + 행동: 기본 구성 요소와는 다른 데코레이터 등을 인스턴스 변수에 저장하는 방식으로 연결
  - **주의할 점**: 구상 구성 요소로 들어가는 코드를 만든다면 데코레이터 패턴 사용을 다시 한번 생각해야 한다.
### 생각해보기
  - p.116 뇌단련 문제 => 상속보다는 구성을 사용하라는 원칙을 지키지 않았고, 관리의 용이성을 생각하지 않았다.
* * *
#### 과제
  - 데코레이터 패턴 적용 코드 C++로 구현 [완료](https://github.com/noodlechoi/DesignPattern/tree/main/Practice/Chapter3)


Chapter 4. 팩토리 패턴
=========
### 변화의 문제
  - 구상 클래스 사용 시 새로운 구상 클래스가 추가될 때마다 코드를 고쳐야한다.
  - 반면, 인터페이스를 바탕으로 만들어진 코드는 어떤 클래스든 특정 인터페이스만 구현하면 사용 가능하기 때문에 여러 변화에 대응 가능하다.
### 팩토리 만들기
  - 팩토리란? => 객체 생성을 처리하는 클래스이다.
  - 정적 팩토리
      + 정적 메소드를 사용하는 팩토리
      + 객체 생성 메소드를 실행하려고 객체의 인스턴스를 만들지 않아도 된다.
      + 그러나, 서브클래스를 만들어서 객체 생성 메소드의 행동을 변경할 수 없다.
  - 팩토리 메소드는 객체 생성을 서브클래스에 캡슐화할 수 있다.
### 팩토리 메소드 패턴
  - 객체를 생성할 때 필요한 인터페이스를 만든다.
  - 클래스 인스턴스를 만드는 일을 서브클래스에게 맡기게 된다.
  - 형식 안정성 보장: 매개변수 형식을 나타내는 객체 만들기, enum 사용
  - 간단한 팩토리와의 차이
    + 재사용 가능한 프레임워크를 만들 수 있다.
    + 생성하는 제품을 마음대로 변경하여 더 유연하다.
### 의존성 뒤집기 원칙
  - 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다.
  - 고수준 구성 요소: 저수준 구성 요소에 의해 정의되는 행동이 들어있는 구성 요소
  - 원칙 지키는 법
    + 변수에 구상 클래스의 레퍼런스를 저장하지 않는다.
    + 추상화된 것부터 클래스를 만들어야 한다.
    + 베이스 클래스에 이미 구현되어 있는 메소드를 오버라이드하지 않는다.
### 추상 팩토리 패턴
  - 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생산하는 인터페이스를 제공하는 패턴이다.
  - 클라이언트와 팩토리에서 생산되는 제품을 분리할 수 있다.
  - 일련의 제품을 만드는  데 쓰이는 인터페이스를 정의하기 위해 만들어진 것이다.
### 팩토리 메소드 패턴과 추상 팩토리 패턴의 공통점과 차이점
  - 공통점: 클라이언트와 구상 형식을 분리한다.
  - 팩토리 메소드 패턴
    + 객체 생성을 서브클래스에 위임하여 어떤 클래스의 인스턴스를 생성할지 결정하는 패턴이다.
    + 주로 단일 객체의 생성에 사용된다.
    + 상속을 사용하여 제품을 만든다.
  - 추상 팩토리 패턴
    + 관련된 객체들의 군을 생성하는 인터페이스를 제공한다.
    + 서로 연관되거나 의존적인 객체들을 일관된 방식으로 생성하는 데 사용된다.
    + 객체 구성을 사용하여 제품을 만든다.
### 생각해보기
* * *
#### 과제
  - 피자 코드 C++로 구현 [완료](https://github.com/noodlechoi/DesignPattern/tree/main/Practice/Chapter4)


Chapter 5. 싱글턴 패턴
=========
### 싱글턴 패턴
  - 클래스 인스턴스를 하나만 만들고, 그 인스턴스로의 전역 접근을 제공한다.
  - 전역변수처럼 사용할 수 있는 패턴이다.
  - 게으른 인스턴스 생성(lazyinstantiation): 인스턴스를 필요한 상황에서 생성하는 것이다.
  - 생성자를 private으로 지정하고, 객체를 리턴해주는 클래스 전역 메소를 만든다.
### 멀티쓰레딩 문제
  - 문제: if문에 두 쓰레드 모두 들어가서 객체가 2개 생길 수 있다.
  - 1차 해결법: getInstance 함수에 synchronized 키워드 붙이기 => 속도 문제 발생
  - 2차 해결법
    1. 속도가 중요하지 않다면 그대로 둔다.
    2. 정적 초기화 부분(static initializer)에서 인스턴스를 생성한다.
    3. DCL(Double-Checked Locking)을 사용하여 동기화되는 부분을 줄인다.
### 싱글턴 패턴의 문제
  - 리플렉션, 직렬화, 역직렬화 문제가 있다.
  - '느슨한 결합 원칙'에 위배된다.
  - 해결: enum 사용
### 생각해보기
  - p210 뇌단련 문제 => 멀티 쓰레드 사용 시 empty, boiled 변수가 중간에 바뀔 수 있다.


Chapter 6. 커맨드 패턴
=========
### 커맨드 패턴
  - 커맨드 객체를 추가하여 메소드 호출을 캡슐화한다.
  - 호출되는 코드와 실제로 일을 처리하는 코드를 분리하는 패턴이다.
  - 요청 내역을 객체로 캡슐화하여 객체를 서로 다른 요청 내역에 따라 매개변수화할 수 있다.
  - 요청을 큐에 저장하거나 로그로 기록하거나 작업 취소 기능을 사용할 수 있다.
  - 널 객체: 클라이언트가 null을 처리하지 않게 하고 싶을 때 사용한다.
  - 람다 표현식을 사용하여 객체의 인스턴스 생성 대신 함수 객체를 사용할 수 있다. 단, Command 인터페이스에 추상 메소드가 하나일 때만 사용 가능하다. 
### 커맨드 패턴 순서
  1. 클라이언트에서 커맨드 객체를 생성한다. 이때 커맨드 객체는 행동과 리시버의 정보가 들어있다.
  2. setCommand()를 호출하여 인보커에 커맨드 객체를 저장한다.
  3. 클라이언트에서 인보커에게 커맨드 객체의 메소드를 호출하라고 요청한다.
  4. 리시버에 있는 행동 메소드가 호출된다.
### 커맨드 패턴 더 활용하기
  1. 스케쥴러, 스레드 풀, 작업 큐 등에 적용 가능하다.
  2. 로그에 기록하여 복구 시스템을 구축하는데 사용 가능하다.
### 생각해보기
  - p241 뇌단련 문제 => 인보커는 커맨드 객체를 저장하고, 리시버는 그 커맨드 객체 안에서 저장되어 캡슐화된다.
* * *
### 과제
  - 커맨드 패턴 구현 [완료](https://github.com/noodlechoi/DesignPattern/tree/main/Practice/Chapter6)


Chapter 7. 어댑터 패턴과 퍼사드 패턴
=========
### 어댑터
  - 코드를 바꾸지 않고, 인터페이스를 클라이언트에서 요구하는 형태로 적응시키는 역할을 한다.