Chapter 1. 전략 패턴
=========
### 객체지향 기초
  - 추상화
  - 캡슐화
  - 다형성
  - 상속
### 객체지향 원칙
  - 바뀌는 부분은 캡슐화
  - 상속보다는 구성
  - 구현보다 인터페이스에 포커싱
### 전략 패턴이란?
  - 알고리즘군을 정의하고 캡슐화해서 각각의  알고리즘군을 수정해서 쓸 수 있게 해주는 디자인 패턴.
### 생각해보기
  - 나중에 어떻게 바뀔 것인가? (재사용성, 확장성, 관리 용이성)
* * *
#### 과제
  - 오리 코드 테스트 C++로 바꿔보기 [완료](https://github.com/noodlechoi/DesignPattern/tree/main/Practice/Chapter1)
  - 인터페이스 vs 추상 클래스 차이 정리
    + 인터페이스는 상태나 구현을 가질 수 없지만, 추상 클래스는 가질 수 있다.
    + [링크](https://velog.io/@hyongti/C%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs.-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%ED%81%B4%EB%9E%98%EC%8A%A4)
  - 낱말 퀴즈 풀기


Chapter 2.  옵저버 패턴
=========
### 옵저버 패턴이란?
  - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다. 신문사와 구독자 관계와 유사하다.
### 느슨한 결합(Loose Coupling)
  - 객체 끼리 상호작용할 수는 있지만, 서로를 잘 모르는 관계를 의미
  - 유연성이 좋아진다.
### 생각해보기
  - 측정치를 직접 전달하는 방법 말고 갱신된 상태를 옵저버에게 전달하는 다른 접근법은 무엇이 있을지?
* * *
#### 과제
  - 기상 스테이션 코드 C++로 구현


Chapter 3.  데코레이터 패턴
=========
### OCP(Open-Closed Principle)
  - 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야한다는 디자인 원칙.
  - 무조건 적용한다면 시간 낭비를 하거나 복잡하고 이해하기 힘든 코드를 만들게 될 수 있다.
### 데코레이터 패턴이란?
  - 동적으로 추가 요소를 더할 수 있도록 하는 디자인 패턴이다.
  - 상속으로 행동을 물려받는 것이 아니라 형식을 맞추는 것이다.
### 생각해보기
  - p.166, p126 뇌단련 문제
* * *
#### 과제
  - 데코레이터 패턴 적용 코드 C++로 구현
