###### [헤드 퍼스트 패턴 깃허브](https://github.com/IT-Book-Organization/HeadFirst-DesignPattern)
* * *
Chapter 1. 전략 패턴
=========
### 객체지향 기초
  - 추상화
  - 캡슐화
  - 다형성
  - 상속
### 객체지향 원칙
  - 바뀌는 부분은 캡슐화
  - 상속보다는 구성
  - 구현보다 인터페이스에 포커싱
### 전략 패턴이란?
  - 알고리즘군을 정의하고 캡슐화해서 각각의  알고리즘군을 수정해서 쓸 수 있게 해주는 디자인 패턴.
### 생각해보기
  - 나중에 어떻게 바뀔 것인가? (재사용성, 확장성, 관리 용이성)
* * *
#### 과제
  - 오리 코드 테스트 C++로 바꿔보기 [완료](https://github.com/noodlechoi/DesignPattern/tree/main/Practice/Chapter1)
  - 인터페이스 vs 추상 클래스 차이 정리
    + 인터페이스는 상태나 구현을 가질 수 없지만, 추상 클래스는 가질 수 있다.
    + [링크](https://velog.io/@hyongti/C%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs.-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%ED%81%B4%EB%9E%98%EC%8A%A4)
  - 낱말 퀴즈 풀기


Chapter 2.  옵저버 패턴
=========
### 옵저버 패턴이란?
  - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다. 신문사와 구독자 관계와 유사하다.
### 느슨한 결합(Loose Coupling)
  - 객체 끼리 상호작용할 수는 있지만, 서로를 잘 모르는 관계를 의미
  - 유연성이 좋아진다.
### 생각해보기
  - 측정치를 직접 전달하는 방법 말고 갱신된 상태를 옵저버에게 전달하는 다른 접근법은 무엇이 있을지? 답: update의 인자를 없애고 getter로 값을 받는다.
* * *
#### 과제
  - 기상 스테이션 코드 C++로 구현 [완료](https://github.com/noodlechoi/DesignPattern/tree/main/Practice/Chapter2)


Chapter 3.  데코레이터 패턴
=========
### OCP(Open-Closed Principle)
  - 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야한다는 디자인 원칙
  - 무조건 적용한다면 시간 낭비를 하거나 복잡하고 이해하기 힘든 코드를 만들게 될 수 있다.
  - 기존 코드는 건들지 않고 확장으로 새로운 동작 추가하기
  - **준수 방법**: 가장 바뀔 가능성이 높은 부분을 중점적으로 살펴보고 적용한다.
### 데코레이터 패턴이란?
  - 동적으로 추가 요소를 더할 수 있도록 하는 디자인 패턴이다.
  - 구상 구성 요소를 감싸 주는 데코레이터를 사용
  - 구성 요소의 클라이언트는 데코레이터의 존재를 알 수 없다.
  - 상속으로 행동을 물려받는 것이 아니라 형식을 맞추는 것이다.
    + 형식을 맞추는 이유: 구성 요소에 자신이 들어가야하기 때문이다.
    + 행동: 기본 구성 요소와는 다른 데코레이터 등을 인스턴스 변수에 저장하는 방식으로 연결
  - **주의할 점**: 구상 구성 요소로 들어가는 코드를 만든다면 데코레이터 패턴 사용을 다시 한번 생각해야 한다.
### 생각해보기
  - p.116 뇌단련 문제 => 상속보다는 구성을 사용하라는 원칙을 지키지 않았고, 관리의 용이성을 생각하지 않았다.
* * *
#### 과제
  - 데코레이터 패턴 적용 코드 C++로 구현 [완료](https://github.com/noodlechoi/DesignPattern/tree/main/Practice/Chapter3)


Chapter 4. 팩토리 패턴
=========
### 변화의 문제
  - 구상 클래스 사용 시 새로운 구상 클래스가 추가될 때마다 코드를 고쳐야한다.
  - 반면, 인터페이스를 바탕으로 만들어진 코드는 어떤 클래스든 특정 인터페이스만 구현하면 사용 가능하기 때문에 여러 변화에 대응 가능하다.
### 팩토리 만들기
  - 팩토리란? => 객체 생성을 처리하는 클래스이다.
  - 정적 팩토리
      + 정적 메소드를 사용하는 팩토리
      + 객체 생성 메소드를 실행하려고 객체의 인스턴스를 만들지 않아도 된다.
      + 그러나, 서브클래스를 만들어서 객체 생성 메소드의 행동을 변경할 수 없다.
  - 팩토리 메소드는 객체 생성을 서브클래스에 캡슐화할 수 있다.
### 팩토리 메소드 패턴
  - 객체를 생성할 때 필요한 인터페이스를 만든다.
  - 클래스 인스턴스를 만드는 일을 서브클래스에게 맡기게 된다.
  - 형식 안정성 보장: 매개변수 형식을 나타내는 객체 만들기, enum 사용
  - 간단한 팩토리와의 차이
    + 재사용 가능한 프레임워크를 만들 수 있다.
    + 생성하는 제품을 마음대로 변경하여 더 유연하다.
### 의존성 뒤집기 원칙
  - 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다.
  - 고수준 구성 요소: 저수준 구성 요소에 의해 정의되는 행동이 들어있는 구성 요소
### 생각해보기
  - p.145, 150 뇌단련 문제
* * *
#### 과제
  - 
