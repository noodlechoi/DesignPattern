###### [헤드 퍼스트 패턴 깃허브](https://github.com/IT-Book-Organization/HeadFirst-DesignPattern)
[클래스](https://kangworld.tistory.com/240)
* * *
# 목차
1. [전략 패턴](#chapter-1-전략-패턴)
2. [옵저버 패턴](#chapter-2-옵저버-패턴)
3. [데코레이터 패턴](#chapter-3-데코레이터-패턴)
4. [팩토리 패턴](#chapter-4-팩토리-패턴)
5. [싱글턴 패턴](#chapter-5-싱글턴-패턴)
6. [커맨드 패턴](#chapter-6-커맨드-패턴)
7. [어댑터 패턴과 퍼사드 패턴](#chapter-7-어댑터-패턴과-퍼사드-패턴)
8. [템플릿 메소드 패턴](#chapter-8-템플릿-메소드-패턴)
9. [반복자 패턴과 컴포지트 패턴](#chapter-9-반복자-패턴과-컴포지트-패턴)
10. [상태 패턴](#chapter-10-상태-패턴)
11. [프록시 패턴](#chapter-11-프록시-패턴)
12. [복합 패턴](#chapter-12-복합-패턴)
13. [실전 디자인 패턴](#chapter-13-실전-디자인-패턴)
14. [기타 패턴](#chapter-14-기타-패턴)

## 객체지향 원칙
- 바뀌는 부분은 캡슐화한다.
- 상속보다 구성을 활용한다.
- 구현보다 인터페이스에 맞춰서 프로그래밍한다.
- 상호작용하는 객체 사이에는 가능하면 느슨한 결합을 사용해야 한다.
- 클래스는 확장에는 열려있지만 변경에는 닫혀 있어야한다(OCP).
- 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다.
- 진짜 절친에게만 이야기한다.
- 먼저 연락하지 마세요. 저희가 연락 드리겠습니다.
- 어떤 클래스가 바뀌는 이유는 하나뿐이어야만 한다.

* * *
Chapter 1. 전략 패턴
=========
### 객체지향 기초
  - 추상화
  - 캡슐화
  - 다형성
  - 상속
### 객체지향 원칙
  - 바뀌는 부분은 캡슐화
  - 상속보다는 구성
  - 구현보다 인터페이스에 포커싱
### 전략 패턴이란?
  - 알고리즘군을 정의하고 캡슐화해서 각각의  알고리즘군을 수정해서 쓸 수 있게 해주는 디자인 패턴.
### 생각해보기
  - 나중에 어떻게 바뀔 것인가? (재사용성, 확장성, 관리 용이성)
* * *
#### 과제
  - 오리 코드 테스트 C++로 바꿔보기 [완료](https://github.com/noodlechoi/DesignPattern/tree/main/Practice/Chapter1)
  - 인터페이스 vs 추상 클래스 차이 정리
    + 인터페이스는 상태나 구현을 가질 수 없지만, 추상 클래스는 가질 수 있다.
    + [링크](https://velog.io/@hyongti/C%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs.-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%ED%81%B4%EB%9E%98%EC%8A%A4)
  - 낱말 퀴즈 풀기


Chapter 2. 옵저버 패턴
=========
### 옵저버 패턴이란?
  - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다. 신문사와 구독자 관계와 유사하다.
### 느슨한 결합(Loose Coupling)
  - 객체 끼리 상호작용할 수는 있지만, 서로를 잘 모르는 관계를 의미
  - 유연성이 좋아진다.
### 생각해보기
  - 측정치를 직접 전달하는 방법 말고 갱신된 상태를 옵저버에게 전달하는 다른 접근법은 무엇이 있을지? 답: update의 인자를 없애고 getter로 값을 받는다.
* * *
#### 과제
  - 기상 스테이션 코드 C++로 구현 [완료](https://github.com/noodlechoi/DesignPattern/tree/main/Practice/Chapter2)


Chapter 3. 데코레이터 패턴
=========
### OCP(Open-Closed Principle)
  - 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야한다는 디자인 원칙
  - 무조건 적용한다면 시간 낭비를 하거나 복잡하고 이해하기 힘든 코드를 만들게 될 수 있다.
  - 기존 코드는 건들지 않고 확장으로 새로운 동작 추가하기
  - **준수 방법**: 가장 바뀔 가능성이 높은 부분을 중점적으로 살펴보고 적용한다.
### 데코레이터 패턴이란?
  - 동적으로 추가 요소를 더할 수 있도록 하는 디자인 패턴이다.
  - 구상 구성 요소를 감싸 주는 데코레이터를 사용
  - 구성 요소의 클라이언트는 데코레이터의 존재를 알 수 없다.
  - 상속으로 행동을 물려받는 것이 아니라 형식을 맞추는 것이다.
    + 형식을 맞추는 이유: 구성 요소에 자신이 들어가야하기 때문이다.
    + 행동: 기본 구성 요소와는 다른 데코레이터 등을 인스턴스 변수에 저장하는 방식으로 연결
  - **주의할 점**: 구상 구성 요소로 들어가는 코드를 만든다면 데코레이터 패턴 사용을 다시 한번 생각해야 한다.
### 생각해보기
  - p.116 뇌단련 문제 => 상속보다는 구성을 사용하라는 원칙을 지키지 않았고, 관리의 용이성을 생각하지 않았다.
* * *
#### 과제
  - 데코레이터 패턴 적용 코드 C++로 구현 [완료](https://github.com/noodlechoi/DesignPattern/tree/main/Practice/Chapter3)


Chapter 4. 팩토리 패턴
=========
### 변화의 문제
  - 구상 클래스 사용 시 새로운 구상 클래스가 추가될 때마다 코드를 고쳐야한다.
  - 반면, 인터페이스를 바탕으로 만들어진 코드는 어떤 클래스든 특정 인터페이스만 구현하면 사용 가능하기 때문에 여러 변화에 대응 가능하다.
### 팩토리 만들기
  - 팩토리란? => 객체 생성을 처리하는 클래스이다.
  - 정적 팩토리
      + 정적 메소드를 사용하는 팩토리
      + 객체 생성 메소드를 실행하려고 객체의 인스턴스를 만들지 않아도 된다.
      + 그러나, 서브클래스를 만들어서 객체 생성 메소드의 행동을 변경할 수 없다.
  - 팩토리 메소드는 객체 생성을 서브클래스에 캡슐화할 수 있다.
### 팩토리 메소드 패턴
  - 객체를 생성할 때 필요한 인터페이스를 만든다.
  - 클래스 인스턴스를 만드는 일을 서브클래스에게 맡기게 된다.
  - 형식 안정성 보장: 매개변수 형식을 나타내는 객체 만들기, enum 사용
  - 간단한 팩토리와의 차이
    + 재사용 가능한 프레임워크를 만들 수 있다.
    + 생성하는 제품을 마음대로 변경하여 더 유연하다.
### 의존성 뒤집기 원칙
  - 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다.
  - 고수준 구성 요소: 저수준 구성 요소에 의해 정의되는 행동이 들어있는 구성 요소 [예시](https://kkeolmusae.tistory.com/90)
  - 원칙 지키는 법
    + 변수에 구상 클래스의 레퍼런스를 저장하지 않는다.
    + 추상화된 것부터 클래스를 만들어야 한다.
    + 베이스 클래스에 이미 구현되어 있는 메소드를 오버라이드하지 않는다.
### 추상 팩토리 패턴
  - 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생산하는 인터페이스를 제공하는 패턴이다.
  - 클라이언트와 팩토리에서 생산되는 제품을 분리할 수 있다.
  - 일련의 제품을 만드는  데 쓰이는 인터페이스를 정의하기 위해 만들어진 것이다.
### 팩토리 메소드 패턴과 추상 팩토리 패턴의 공통점과 차이점
  - 공통점: 클라이언트와 구상 형식을 분리한다.
  - 팩토리 메소드 패턴
    + 객체 생성을 서브클래스에 위임하여 어떤 클래스의 인스턴스를 생성할지 결정하는 패턴이다.
    + 주로 단일 객체의 생성에 사용된다.
    + 상속을 사용하여 제품을 만든다.
  - 추상 팩토리 패턴
    + 관련된 객체들의 군을 생성하는 인터페이스를 제공한다.
    + 서로 연관되거나 의존적인 객체들을 일관된 방식으로 생성하는 데 사용된다.
    + 객체 구성을 사용하여 제품을 만든다.
### 생각해보기
[팩토리 GPT 정리](https://chatgpt.com/share/687f670c-773c-8012-b118-518f501d346d)
* * *
#### 과제
  - 피자 코드 C++로 구현 [완료](https://github.com/noodlechoi/DesignPattern/tree/main/Practice/Chapter4)


Chapter 5. 싱글턴 패턴
=========
### 싱글턴 패턴
  - 클래스 인스턴스를 하나만 만들고, 그 인스턴스로의 전역 접근을 제공한다.
  - 전역변수처럼 사용할 수 있는 패턴이다.
  - 게으른 인스턴스 생성(lazyinstantiation): 인스턴스를 필요한 상황에서 생성하는 것이다.
  - 생성자를 private으로 지정하고, 객체를 리턴해주는 클래스 전역 메소드를 만든다.
### 멀티쓰레딩 문제
  - 문제: if문에 두 쓰레드 모두 들어가서 객체가 2개 생길 수 있다.
  - 1차 해결법: getInstance 함수에 synchronized 키워드 붙이기 => 속도 문제 발생
  - 2차 해결법
    1. 속도가 중요하지 않다면 그대로 둔다.
    2. 정적 초기화 부분(static initializer)에서 인스턴스를 생성한다.
    3. DCL(Double-Checked Locking)을 사용하여 동기화되는 부분을 줄인다.
### 싱글턴 패턴의 문제
  - 리플렉션, 직렬화, 역직렬화 문제가 있다.
  - '느슨한 결합 원칙'에 위배된다.
  - 해결: enum 사용
### 생각해보기
  - p210 뇌단련 문제 => 멀티 쓰레드 사용 시 empty, boiled 변수가 중간에 바뀔 수 있다.


Chapter 6. 커맨드 패턴
=========
### 커맨드 패턴
  - 커맨드 객체를 추가하여 메소드 호출을 캡슐화한다.
  - 호출되는 코드와 실제로 일을 처리하는 코드를 분리하는 패턴이다.
  - 요청 내역을 객체로 캡슐화하여 객체를 서로 다른 요청 내역에 따라 매개변수화할 수 있다.
  - 요청을 큐에 저장하거나 로그로 기록하거나 작업 취소 기능을 사용할 수 있다.
  - 널 객체: 클라이언트가 null을 처리하지 않게 하고 싶을 때 사용한다.
  - 람다 표현식을 사용하여 객체의 인스턴스 생성 대신 함수 객체를 사용할 수 있다. 단, Command 인터페이스에 추상 메소드가 하나일 때만 사용 가능하다. 
### 커맨드 패턴 순서
  1. 클라이언트에서 커맨드 객체를 생성한다. 이때 커맨드 객체는 행동과 리시버의 정보가 들어있다.
  2. setCommand()를 호출하여 인보커에 커맨드 객체를 저장한다.
  3. 클라이언트에서 인보커에게 커맨드 객체의 메소드를 호출하라고 요청한다.
  4. 리시버에 있는 행동 메소드가 호출된다.
### 커맨드 패턴 더 활용하기
  1. 스케쥴러, 스레드 풀, 작업 큐 등에 적용 가능하다.
  2. 로그에 기록하여 복구 시스템을 구축하는데 사용 가능하다.
### 생각해보기
  - p241 뇌단련 문제 => 인보커는 커맨드 객체를 저장하고, 리시버는 그 커맨드 객체 안에서 저장되어 캡슐화된다.
* * *
### 과제
  - 커맨드 패턴 구현 [완료](https://github.com/noodlechoi/DesignPattern/tree/main/Practice/Chapter6)


Chapter 7. 어댑터 패턴과 퍼사드 패턴
=========
### 어댑터
  - 코드를 바꾸지 않고, 인터페이스를 클라이언트에서 요구하는 형태로 적응시키는 역할을 한다.
### 어댑터 패턴
  - 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환한다.
  - 어댑티를 감쌀 때 객체 구성을 사용한다. 이런 접근법은 어댑티의 모든 서브클래스에 어댑티를 쓸 수 있다는 장점이 있다.
  - 객체 어댑터와 클래스 어댑터 차이
    + 객체 어댑터: 구성으로 어댑티에 요청을 전달한다.(구성)
    + 클래스 어댑터: 타깃과 어댑티 모두 서브클래스로 만들어서 사용한다.(상속)
  - 코드와 비교
    + TurkeyAdapter: 어댑터
    + Duck: 타깃 인터페이스
    + Turkey: 어댑티 인터페이스
  - 클라이언트에서 사용하는 방법
    1. 클라이언트에서 타깃 인터페이스로 메소드를 호출해서 어댑터에 요청을 보낸다.
    2. 어댑터는 어댑티 인터페이스로 그 요청을 어댑티에 대한 메소드 호출로 변환한다.
  - Enumeration을 Iterator에 적응시킬 때처럼 일대일 대응되지 않는 상황에서는 어댑터를 완벽하게 적응할 수 없다.
### 퍼사드 패턴
  - 퍼사드(facade): 겉모양이나 외관을 뜻한다.
  - 인터페이스를 간단하게 변경한다.
  - 작동 원리
    1. 간단한 메소드가 들어있는 퍼사드 클래스를 새로 만든다.
    2. 퍼사드 클래스는 구성 요소를 하나의 서브시스템으로 간주하고, 메소드는 서브시스템의 메소드를 호출해서 필요한 작업을 처리한다.
    3. 클라이언트 코드는 서브시스템이 아닌 퍼사드에 있는 메소드를 호출한다.
    4. 퍼사드를 쓰더라도 서브시스템에 직접 접근할 수 있다. (서브시스템 클래스 객체화X)
### 두 패턴의 차이점
  - 어댑터 패턴: 인터페이스를 변경해서 클라이언트에서 필요로 하는 인터페이스로 적응시키는 용도로 사용한다.(변환)
  - 퍼사드 패턴: 어떤 서브시스템에 대한 간단한 인터페이스를 제공하는 용도로 사용된다.(단순하게 생성, 통합)
### 최소 지식 원칙(Principle of Least Knowledge)
  - 객체 사이의 상호작용은 가까운 친구 사이에만 허용하는 원칙이다.
  - 객체와 상호작용하는 클래스의 개수와 방식에 주의를 기울여야한다는 원칙이다.
  - 친구를 만들지 않는 가이드 라인
    + 객체 자체
    + 메소드에 매개변수로 전달된 객체
    + 메소드를 생성하거나 인스턴스를 만든 객체
    + 객체에 속하는 구성 요소(인스턴스 변수에 의해 참조되는 객체)
### 생각해보기
  - p280 뇌단련 문제
    + 객체: 어댑터 코드에 행동을 추가하면 그 어댑터 코드는 어댑티 클래스와 모든 서브클래스에 그대로 적용된다.
    + 클래스: 특정 어댑티 클래스에만 적용할 수 있다. 대신 어댑티 전체를 다시 구현하지 않아도 된다.
* * *
### 과제
  - 클래스 어댑터 만들기, 퍼사드 클래스 만들기 [완료](https://github.com/noodlechoi/DesignPattern/tree/main/Practice/Chapter7)


Chapter 8. 템플릿 메소드 패턴
=========
### 템플릿 메소드 패턴
  - 알고리즘의 골격을 정의한다.
  - 알고리즘의 일부 단계를 서브클래스에서 구현하거나 재정의할 수 있다.
  - 템플릿 메소드와 구상 단계는 오버라이드하지 못하도록 final로 선언한다.
### 후크
  - 추상 클래스에서 선언되지만 기본적인 내용만 구현되어있거나 아무 코드도 들어있지 않은 메소드이다.
  - 사용시 서브클래스에서 후크를 오버라이드해야 한다.
  - 알고리즘의 특정 단계가 선택적으로 적용된다면 사용한다.
  - 기회를 제공하는 용도로도 사용할 수 있다.
### 할리우드 원칙(Hollywwod principle)
  - 의존성 부패(dependency rot) 방지
  - 의존성 부패: 의존성이 복잡하게 꼬여있는 상황
  - 저수준 구성 요소가 시스템에 접속할 수는 있지만 언제 어떻게 그 구성 요소를 사용할지는 고수준 구성 요소가 결정한다.
  - 템플릿 메소드 패턴, 옵저버, 팩토리 메소드 등은 이 원칙을 사용한다.
  - 의존성 뒤집기 원칙과 공통점 및 차이
    + 공통점: 객체를 분리한다.
    + 차이점: 의존성을 피하는 방법에 있어서 뒤집기 원칙이 더 강하고 일반적이다.
### 생각해보기
  - p316 뇌단련 문제: 달라보이는 두 개의 메소드도 목적어만 다를 뿐 우려내고 추가하는 행동은 같음 => 알고리즘이 똑같음!
* * *
### 과제
  - 템플릿 메소드 패턴 구현 [완료](https://github.com/noodlechoi/DesignPattern/tree/main/Practice/Chapter8)


Chapter 9. 반복자 패턴과 컴포지트 패턴
=========
### 반복자 패턴
  - Iterator 인터페이스에 의존한다.
  - 컬렉션의 구현 방법을 노출하지 않으면서 집합체 내의 모든 항목에 접근하는 방법을 제공한다.
  - 각 항목에 일일이 접근할 수 있게 해 주는 기능을 집합체가 아닌 반복자 객체가 책임진다.
### 단일 역할 원칙
  - 어떤 클래스가 바뀌는 이유는 하나뿐이어야 한다.
  - 어떤 클래스가 맡고 있는 모든 역할은 나중에 코드의 변화를 불러올 수 있으므로 하나의 클래스는 하나의 역할만 맡아야 한다는 원칙이다.
  - 응집도(conhesion)과 밀접한 관련이 있다.
### Iterable 인터페이스
  - 어떤 클래스에서 Iterable을 구현한다면 iterator() 메소드를 구현한다. 그 메소드는 인터페이스를 구현하는 반복자를 리턴한다.
  - 이 인터페이스에는 컬랙션을 대상으로 반복 작업을 수행하는 forEach() 메소드가 기본으로 포함된다. 그러나 배열은 해당 인터페이스가 구현되지 않는다.
### 컴포지트 패턴
  - 객체를 트리구조로 구성해서 부분-전체 계층 구조(part-whole hierarchy)를 구현한다.
  - 이 패턴을 사용하면 클라이언트에서 개별 객체와 복합 객체를 똑같은 방법으로 다룰 수 있다.
  - 단일 역할 원칙을 깨는 대신 투명성(transparency)을 확보하는 패턴이다. 어떤 원소가 복합 객체인지 잎인지 클라이언트에게 투명하게 보인다.
  - 클라이언트를 단순화시킬 수 있다.
  - 구성 요소
    + 복합 객체(composite object): 다른 구성 요소를 포함하고 있는 구성 요소
    + 잎 객체(leaf object): 구성 요소를 포함하지 않는 구성 요소
  - 복합 객체와 잎 객체에 똑같은 메소드를 호출하여 객체들을 똑같이 다룬다.
  - 인터페이스를 똑같이 만들기 위해 아무 의미없는 메소드가 생길 수 있다. 그런 메소드는 널 또는 false를 리턴하거나 예외를 던지게 한다.
  - 서로 다른 객체에 서로 다른 인터페이스를 요구해서 엉뚱한 메소드가 호출되지 않게 할 수 있다. 그러나 메소드를 호출하기 전에 객체의 형식을 매번 확인해야 한다.
  - 복합 구조가 너무 복잡하거나, 복합 객체 전체를 도는데 너무 많은 자원이 필요하다면 복합 노드를 캐싱해둘 수 있다.(ex. 반복된 계산 결과를 임시로 저장하는 캐시를 만들어서 속도 향상)
### 생각해보기
  - p373 뇌단련 문제: 팩토리 메소드 패턴
  - 원칙은 상황에 따라 적절하게 사용해야한다.
* * *
### 과제
  - 반복자 패턴과 컴포지트 패턴 구현 [미완료](https://github.com/noodlechoi/DesignPattern/tree/main/Practice/Chapter9)
  - C++ 공부 후 재구현


Chapter 10. 상태 패턴
=========
### 상태 패턴
  - 상태 클래스를 만들어서 상태 클래스가 행동을 위임하도록 만든다.
  - 사용하면 객체의 내부 상태가 바뀜에 따라서 객체의 행동을 바꿀 수 있다.
  - 마치 객체의 클래스가 바뀌는 것과 같은 결과를 얻을 수 있다.
  - 상태 전환이 동적으로 결정될 때 상태 클래스 내에서 상태 변환을 처리하는 것이 좋다.
  - 상태 전환 코드를 상태 클래스에 넣으면 상태 클래스 사이에 의존성이 생기는 단점이 있다. 이를 게터 메소드 등을 사용하여 최소화할 수 있다.
  - 상태 관리는 전적으로 Context가 책임져야한다.
  - 상태를 공유할 때는 각 상태를 정적 인스턴스 변수에 할당하는 방법을 사용한다.
  - 전략 패턴과 다이어그램은 똑같지만 용도가 다르다.
    + 상태 패턴: 상대 객체에 일련의 행동이 캡슐화된다. 클라이언트를 상태 객체를 몰라도 된다. 행동을 상태 객체 내에 캡슐화하여 객체의 행동을 바꿀 수 있다.
    + 전략 패턴: 클라이언트가 Context 객체에게 어떤 전략 객체를 사용할지 지정해 준다. 전략 객체를 변경할 수 있는 유연성을 제공한다. 행동을 정의하는 객체를 유연하게 바꿀 수 있다.
### 생각해보기
  - p435 뇌단련 문제: turnCrank()에서 bool값을 리턴하게 하거나 예외를 도입하면 해결할 수 있다.
* * *
### 과제
  - 상태 패턴 구현 [완료](https://github.com/noodlechoi/DesignPattern/tree/main/Practice/Chapter_10)


Chapter 11. 프록시 패턴
=========
### 프록시(proxy)
  - 원격 프록시는 원격 객체의 로컬 대변자 역할을 한다.
  - 클라이언트 보조 객체와 같다.
  - 프록시 종류
    + 원격 프록시: 호출이 네트워크로 전달되어 원격 객체의 메소드가 호출된다.
    + 가상 프록시: 생성하는데 많은 비용이 드는 객체를 대신하여 진짜 객체가 필요한 상황이 오기 전까지 객체 생성을 미룬다.
    + 보호 프록시: 접근 권한을 바탕으로 객체로의 접근을 제어한다.
    + 캐싱 프록시: 기존 객체들을 캐시에 저장했다가 요청이 왔을 때 객체를 리턴한다. 계산 시간과 네트워크 지연을 줄여 준다. 웹 서버 또는 컨텐츠 관리 및 퍼블리싱 시스템에 주로 쓰인다.
    + 방화벽 프록시(firewall): 일련의 네트워크 자원으로의 접근을 제어한다. 나쁜 클라이언트로부터 보호한다. 주로 기업용 방화벽 시스템에 쓰인다.
    + 스마트 레퍼런스 프록시: 객체의 레퍼런스의 개수를 세는 방식처럼 주제가 참조될 때마다 추가 행동을 제공한다.
    + 동기화 프록시(synchronization): 여러 스레드에서 주제에 접근할 때 안전하게 작업을 처리할 수 있게 해준다.
    + 복잡도 숨김 프록시(complexity hiding): 복잡한 클래스의 집합으로의 접근을 제어하고 그 복잡도를 숨겨준다. 퍼사드 프록시라고도 부른다.
    + 지연 복사 프록시(copy-on-write): 클라이언트에서 필요할 때까지 객체가 복사되는 것을 지연하여 객체의 복사를 제어한다. 변형된 가상 프록시이다.
### 프록시 패턴
  - 특정 객체로의 접근을 제어하는 대리인을 제공한다.
  - 접근 제어 방법
    1. 원격 프록시를 사용하여 원격 객체로 접근 제어
    2. 가상 프록시를 사용하여 생성하기 힘든 자원으로의 접근을 제어
    3. 보호 프록시를 사용해서 접근 권한이 필요한 자원으로의 접근 제어
  - 진짜 객체의 인스턴스를 생성해서 리턴하는 팩토리 사용하면 클라이언트에서 프록시를 사용하도록 할 수 있다.
### RMI(Remote Method Invocation)
  - 클라이언트와 서비스 보조 객체를 만들어 준다.
  - 룩업 서비스도 제공해준다.
  - 네트워킹이나 입출력 기능 사용하기 때문에 위험이 따른다.
  - 클라이언트 보조 객체는 스텁(stub), 서비스 보조 객체는 스켈레톤(skeleton)이라고 부른다.
  - 원격 메소드 호출 과정
    1. 클라이언트 보조 객체의 메소드를 호출한다.
    2. 클라이언트 보조 객체는 메소드 호출 정보를 잘 포장해서 네트워크 서비스 보조 객체에게 전달한다.
    3. 서비스 보조 객체는 클라이언트 보조 객체로부터 받은 정보를 해석해서 어떤 객체의 어떤 메소드를 호출할지 알아낸 다음 진짜 서비스 객체의 메소드를 호출한다.
    4. 서비스 객체의 메소드 실행이 끝나면 서비스 보조 객체에 결과를 리턴한다.
    5. 서비스 보조 객체는 호출 결과로 리턴된 정보를 포장해서 네트워크로 클라이언트 보조 객체에게 전달한다.
    6. 클라이언트 보조 객체는 리턴된 정보를 해석해서 클라이언트 객체에게 리턴한다.
  - 원격 서비스 만드는 4단계
    1. 원격 인터페이스 만들기
    2. 서비스 구현 클래스 만들기
    3. RMI 레지스트리(rmiregistry) 실행하기
    4. 원격 서비스 실행하기
  - 스텁이 입출력 작업을 처리할 때 나타나는 위험에 대비하기 위해 모든 메소드를 RemoteException을 던지도록 선언한다.
  - 클라이언트는 룩업으로 스텁 객체를 요청한다.
  - 많이하는 실수
    1. 원격 서비스를 돌리기 전에 RMI레지스트리를 실행하지 않는다.
    2. 인자와 리턴 형식을 직렬화할 수 없게 만든다.
### 생각해보기
  - p497 디자인 퍼즐: 상태 패턴을 사용한다.
  - 데코레이터 패턴과의 차이: 데코레이터는 클래스에 새로운 행동을 추가하지만 프록시는 어떤 클래스로의 접근을 제어하는 용도이다.


Chapter 12. 복합 패턴
=========
### 복합 패턴
  - 여러 가지 문제의 일반적인 해결법을 제시해야 한다.
  - 예시: 모델-뷰-컨트롤러(MVC)
### 모델-뷰-컨트롤러(MVC)
  - 모델: 모든 데이터, 상태와 애플리케이션 로직이 들어있다.
  - 뷰: 모델을 표현하는 방법을 제공한다.
  - 컨트롤러: 사용자로부터 입력을 받으며 입력받은 내용이 모델에게 어떤 의미가 있는지 파악한다.
  - 모델, 뷰, 컨트롤러의 관계
    1. 사용자는 뷰에만 접촉할 수 있다.
    2. 컨트롤러가 모델에게 상태를 변경하라고 요청한다.
    3. 컨트롤러가 뷰를 변경해 달라고 요청할 수도 있다.
    4. 상태가 변경되면 모델이 뷰에게 그 사실은 알린다.
    5. 뷰가 모델에게 상태를 요청한다.
  - 사용되는 패턴
    + 전략 패턴: 뷰와 컨트롤러에 구현되어 있다. 뷰는 어플리케이션의 겉모습에만 신경 쓰고, 인터페이스의 행동을 결정하는 일은 컨트롤러에게 맡긴다.
    + 컴포지트 패턴: 뷰에 구현되어 있다. GUI 구성 요소(레이블, 버튼, 텍스트 항목 등)로 이루어진 복합 객체이다.
    + 옵저버 패턴: 모델은 상태가 변경되었을 때 그 모델과 연관된 객체들에게 연락한다. 뷰와 컨트롤러로부터 완전히 독립시킬 수 있다.
* * *
### 과제
  - 여러 가지 패턴 구현 [완료](https://github.com/noodlechoi/DesignPattern/tree/main/Practice/Chapter_12)


Chapter 13. 실전 디자인 패턴
=========
### 디자인 패턴 정의
  - 디자인 패턴은 일상적이고 반복적으로 등장하는 디자인 문제의 해결책이다.
  - 패턴: 특정 컨텍스트 내에서 주어진 문제의 해결책이다.
  - 컨택스트(context): 패턴이 적용되는 상황을 뜻한다. 반복적으로 일어날 수 있는 상황이어야만 한다. ex) 객체들의 컬렉션
  - 문제(problem): 컨텍스트 내에서 이뤄야 하는 목표를 뜻한다. 컨텍스트 내의 계약조건도 포함된다.
  - 해결책(solution): 우리가 찾아내야 하는 것으로 제약 조건 속에서 누가 적용해도 목표를 이룰 수 있는 일반적인 디자인을 뜻한다.
  - 카탈로그 활용 방법
    1. 모든 패턴 익히기
    2. 여러 사이 패턴 사이 관계 파악하기
    3. 적용 대상 섹션 보고 적절한 패턴인지 판단하기
    4. 결과(Consequences) 부분 확인하기
  - 디자인 패턴 반영 및 구현 방법
    1. 클래스 다이어그램 활용하기
    2. 구조(Structure) 부분 읽기
    3. 구성 요소(Participants) 부분에서 각 클래스 역할을 파악하고 있는지 확인하기
    4. 구현/샘플 코드 부분에서 구현 기법과 주의사항 등 공부하기
### 디자인 패턴 분류하기
  1. 생성, 행동, 구조 3가지 범주로 용도에 따라 분류한다.
  2. 클래스를 다루는 패턴인지, 객체를 다루는 패턴인지에 따라 분류한다.
### 패턴으로 생각하기
  - 디자인 원칙을 바탕으로 제 할 일을 완수할 수 있는 가장 간단한 코드를 만들어야 한다. 즉 디자인 패턴을 남발해서는 안 된다.
  - 확장성이 필요한 경우에만 패턴을 사용하는 것이 좋다.
  1. 최대한 단순한 방법(Keep it Simple)으로 문재를 해결해야 한다.
  2. 적용할 패턴이 설계한 디자인에 미칠 영향과 결과를 생각해 봐야 한다.
  3. 디자인상의 문제에 적합하다는 확신이 든다면 패턴을 도입해야 한다. 패턴 카탈로그의 용도와 적용 대상 부분을 살펴보면 도움이 된다.
  4. 간단한 해결책으로 문제가 해결되는 데도 시스템 변경 부분이 예측되는 상황이라면 디자인 패턴을 사용해야 한다.
  5. 패턴을 사용해서 구조를 개선할 수 있다.
  6. 필요하지 않은 패턴은 제거한다.
### 디자인 패턴 자료
  - 책
    + Gof 디자인 패턴
    + The Timeless Way of Building/ A Pattern Language
  - 웹 사이트
    + [The Portland Patterns Repository](https://wiki.c2.com/?WelcomeVisitors): 패턴과 관련된 위키
    + [The Hillside Group](https://hillside.net/): 프로그래밍과 디자인 관련 내용
    + [O'Reilly Online Learning](https://www.oreilly.com/): 책, 교육과정, 라이브 수업 등
### 안티 패턴
  - 문제의 나쁜 해결책에 이르는 길을 알려 준다.
  - 어떤 이유로 나쁜 해결책에 유혹되는지 알려 준다.
  - 장기적인 관점에서 그 해결책이 나쁜 이유를 알려 준다.
  - 좋은 해결책을 만들 때 적용할 수 있는 다른 패턴을 제안해 준다.
### 생각해보기
  - p600 뇌단련 문제: 패턴이 아니다. 적용된 컨텍스트가 반복적으로 일어나는 상황이 아니라 특수한 상황이기 때문이다.
  - 포스(force): 목적과 일련의 제약조건(문제)

  
Chapter 14. 기타 패턴
=========
### 브리지 패턴(Bridge)
  - 구현과 추상화 부분까지 변경해야할 때 사용한다.
  - 추상화된 부분과 구현 부분을 서로 다른 클래스 계층구조로 분리하여 두 부분 모두 변경할 수 있다. 이 둘 사이의 관계를 브리지라고 부른다.
  - 추상화된 부분에 들어 있는 메소드는 구현 클래스에 있는 메소드를 통해서 구현된다.
  - 구상 서브클래스는 추상 클래스의 메소드로 구현된다.
  - 장점
    + 구현과 인터페이스를 완전히 결합하지 않았기에 구현과 추상화 부분을 분리할 수 있다.
    + 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있다.
    + 추상화 부분을 구현한 구상 클래스가 바뀌어도 클라이언트에는 영향을 끼치지 않는다.
  - 단점
    + 디자인이 복잡하다.
  - 활용법
    + 여러 플랫폼에서 사용해야 하는 그래픽스와 원도우 처리 시스템에 유용하다.
    + 인터페이스와 실제 구현할 부분을 서로 다른 방식으로 변경해야 할 때 유용하다.
### 빌더 패턴(Builder)
  - 제품 생산 단계를 캡슐화하고 싶을 때 사용한다.
  - 반복자 패턴처럼 객체(빌더)에 캡슐화하여 클라이언트가 빌더에게 요청하도록 만든다.
  - 장점
    + 복합 객체 생성 과정을 캡슐화한다.
    + 여러 단계와 다양한 절차를 거쳐 객체를 만들 수 있다.
    + 제품의 내부 구조를 클라이언트로부터 보호할 수 있다.
    + 클라이언트는 추상 인터페이스만 볼 수 있기 때문에 코드를 쉽게 바꿀 수 있다.
  - 단점
    + 팩토리를 사용할 때보다 객체를 만들 때 클라이언트에 관해 더 알아야 한다.
  - 활용법
    + 복합 객체 구조를 구축하는 용도로 사용된다.
### 책임 연쇄 패턴(Chain of Responsibility)
  - 1개의 요청을 2개 이상의 객체에서 처리해야 할 때 사용한다.
  - 주어진 요청을 검토하는 객체 사슬을 생성하여 각 객체는 요청을 직접 처리하거나 사슬에 있는 다른 객체에게 넘긴다.
  - 장점
    + 요청을 보낸 쪽과 받는 쪽을 분리할 수 있다.
    + 객체는 사슬 구조를 몰라도 되고 다른 객체의 직접적인 레퍼런스를 가질 필요가 없으므로 객체를 단순하게 만들 수 있다.
    + 사슬에 들어가는 객체를 바꾸거나 순서를 바꿈으로써 역할을 동적으로 추가하거나 제거할 수 있다.
  - 단점
    + 요청이 반드시 수행된다는 보장이 없다.
    + 실행 시 디버깅하기 힘들다.
  - 활용법
    + 윈도우 시스템에서 마우스 클릭과 키보드 이벤트를 처리할 때 사용된다.
### 플라이웨이트 패턴(Flyweight)
  - 인스턴스 하나로 여러 개의 '가상 인스턴스'를 제공하고 싶을 때 사용한다.
  - 인스턴스를 하나만 만들고 모든 인스턴스의 상태를 클라이언트 객체가 관리하도록 한다.
  - 장점
    + 인스턴스의 개수를 줄여서 메모리를 절약할 수 있다.
    + 여러 가상 객체의 상태를 한 곳에 모아 둘 수 있다.
  - 단점
    + 특정 인스턴스만 다른 인스턴스와 다르게 행동할 수 없다.
  - 활용법
    + 어떤 클래스의 인스턴스가 많이 필요하지만 모두 똑같은 방식으로 제어해야 할 때 사용된다.
### 인터프리터 패턴(Interpreter)
  - 어떤 언어의 인터프리터를 만들 때 사용한다.
  - 문법과 구문을 번역하는 인터프리터 클래스를 기반으로 간단한 언어를 정의한다.
  - 언어에 속하는 규칙을 나타내는 클래스를 사용해서 언어를 표현한다.
  - 장점
    + 문법을 클래스로 표현해서 쉽게 언어를 구현할 수 있다.
    + 문법이 클래스로 표현되므로 쉽게 변경하거나 확장할 수 있다.
    + 클래스 구조에 메소드만 추가하면 프로그램을 해석하는 기본 기능 외에 새로운 기능을 추가할 수 있다.
  - 단점
    + 문법 규칙의 개수가 많아지면 복잡하다.
  - 활용법
    + 간단한 언어를 구현할 때 유용하다.
    + 스크립트 언어와 프로그래밍 언어에서 모두 쓸 수 있다.
### 중재자 패턴(Mediator)
  - 서로 관련된 객체 사이의 복잡한 통신과 제어를 한 곳으로 집중하고 싶을 때 사용한다.
  - 상태가 바뀔 때마다 중재자에게 알려준다. 중재자에서 보낸 요청에 응답한다.
  - 장점
    + 시스템과 객체를 분리함으로써 재사용성을 획기적으로 향상시킬 수 있다.
    + 제어 로직을 한 군데 모아놨으므로 관리하기 수월하다.
    + 시스템에 들어있는 객체 사이에서 오가는 메세지를 줄이고 단순화할 수 있다.
  - 단점
    + 디자인을 잘 하지 못하면 중재자 객체가 복잡해질 수 있다.
  - 활용법
    + 서로 연관된 GUI 구성 요소를 관리하는 용도로 사용된다.
### 메멘토 패턴(Memento)
  - 객체를 이전의 상태로 복구해야 할 때 사용한다.
  - 메멘토 객체: 상태를 핵심 객체로부터 따로 저장하는 객체
  - 목적
    + 시스템에서 핵심적인 기능을 담당하는 객체의 상태 저장
    + 핵심적인 객체의 캡슐화 유지
  - 장점
    + 저장된 상태를 핵심 객체와는 다른 별도의 객체에 보관할 수 있어서 안전하다.
    + 핵심 객체의 데이터를 캡슐화된 상태로 유지할 수 있다.
    + 복구 기능을 구현하기 쉽다.
  - 단점
    + 상태를 저장하고 복구하는데 시간이 오래 걸릴 수 있다.
  - 활용법
    + 메멘토 객체를 사용해서 상태를 저장한다.
    + 자바 시스템에서는 시스템의 상태를 저장할 때 직렬화를 사용하는 것이 좋다.
### 프로토타입 패턴(Prototype)
  - 인스턴스를 만들 때 자원과 시간이 많이 들거나 복잡할 때 사용한다.
  - 기존 인스턴스를 복사하기만 해도 새로운 인스턴스를 만들 수 있다.
  - 클라이언트에서는 생성 인스턴스의 종류를 알 수 없다. 레지스트리에서 클론을 만든 다음 그 클론을 리턴한다.
  - 장점
    + 클라이언트는 새로운 인스턴스를 만드는 과정을 몰라도 된다.
    + 클라이언트는 구체적인 형식을 몰라도 객체를 생성할 수 있다.
    + 상황에 따라서 객체를 새로 생성하는 것보다 객체를 복사하는 것이 효율적일 수 있다.
  - 단점
    + 객체의 복사본을 만드는 일이 복잡할 수도 있다.
  - 활용법
    + 시스템에서 복잡한 클래스 계층구조에 파묻혀 있는 다양한 형식의 객체 인스턴스를 새로 만들어야할 때 유용하다.
### 비지터 패턴(Visitor)
  - 다양한 객체에 새로운 기능을 추가해야 하는데 캡슐화가 중요하지 않을 때 사용한다.
  - 비지터 객체는 트래버서(Traverser) 객체와 함께 돌아간다.
  - 트래버서는 컴포지트 패턴을 쓸 때, 복합 객체 내에 속해 있는 모든 객체에 접근하는 일을 도와준다.
  - 각각의 상태를 모두 가져오면 클라이언트는 비지터에게 각 상태에 맞는 다양한 작업을 처리하도록 요구할 수 있다.
  - 새로운 기능을 추가하더라도 비지터만 고치면 된다.
  - 장점
    + 구조를 변경하지 않으면서도 복합 객체 구조에 새로운 기능을 추가할 수 있다.
    + 비교적 쉽게 새로운 기능을 추가할 수 있다.
    + 비지터가 수행하는 기능과 관련된 코드를 한 곳에 모아 둘 수 있다.
  - 단점
    + 비지터를 사용하면 복합 클래스의 캡슐화가 깨진다.
    + 컬랙션 내의 모든 항목에 접근하는 트래버서가 있으므로 복합 구조를 변경하기가 어려워진다.
* * *
[목차로 이동](#목차)
