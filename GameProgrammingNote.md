# 목차
1. [시작](#chapter-1-구조-성능-게임)
2. [명령](#chapter-2-명령)
3. [경량](#chapter-3-경량)
4. [관찰자](#chapter-4-관찰자)
5. [프로토타입](#chapter-5-프로토타입)
6. [싱글턴](#chapter-6-싱글턴)
7. [상태](#chapter-7-상태)
8. [이중 버퍼](#chapter-8-이중-버퍼)
9. [게임 루프](#chapter-9-게임-루프)
10. [업데이트 메서드](#chapter-10-업데이트-메서드)
11. [바이트코드](#chapter-11-바이트코드)
12. [하위 클래스 샌드박스](#chapter-12-하위-클래스-샌드박스)
13. [타입 객체](#chapter-13-타입-객체)
14. [컴포넌트](#chapter-14-컴포넌트)
15. [이벤트 큐](#chapter-15-이벤트-큐)
16. [서비스 중개자](#chapter-16-서비스-중개자)
# Chapter 1. 구조, 성능, 게임
## 1.1 소프트웨어 구조란?
  ### 좋은 소프트웨어 구조란?
  - 구조는 변경과 관련 있다.
  - 쉽게 변경할 수 있어야 한다.
  - __확장에는 열려있고, 변경에는 닫혀있어야 한다.__
  - __작업에 들어가기 전에 알아야 할 지식의 양을 줄이는 것이다.__
  ### 디커플링
  - 커플링: 한쪽 코드가 없으면 코드를 이해할 수 없는 상황
  - 두 코드를 디커플링하면, 각각을 따로 이해할 수 있다.
  - 어느 한 코드를 변경했을 때 다른 코드를 변경하지 않아도 된다.
## 1.2 비용은?
- 구조 유지에는 많은 노력이 필요하다.
- 확장 가능성을 제공하는 것은 예측을 했기 때문이다. 그러나 만든 모듈을 사용하지 못하면 작업할 코드만 늘어나는 일이 발생한다.
- '엔진'은 게임을 만들기 위해 존재한다.
## 1.3 성능과 속도
- 소프트웨어 구조와 추상화가 런타임 비용을 요구하여 게임 성능을 저하시킨다. 반례로는 C++ 템플릿이 있다.
- 성능은 가정에 기반한다. 최적화 기법은 구체적인 제한을 선호한다.
- 재밌는 게임을 최적화하는 것이 최적화된 게임을 재밌게 만드는 것보다 쉽다.
- 코드를 유연하게 유지하다가 기획이 확실해지면 다음 추상 계층을 제거해 성능을 높이는 방법도 있다.
## 1.4 나쁜 코드의 장점
- 버릴 코드를 적은 시간으로 작성할 수 있다. 단, 버릴 코드는 나중에 확실히 버릴 수 있게 해야 한다.
- 프로토타입용 코드를 다른 언어로 작성하여 반드시 코드를 재작성하도록 만들 수 있다.
## 1.5 균형 잡기
- 목표
  1. 구조 깔끔하게 만들기
  2. 실행 성능 최적화
  3. 개발 중인 기능 빠르게 구현
  - 정리: 장기적인 개발 속도, 게임 실행 속도, 단기적인 개발 속도
- 최적화 이후 코드가 고착되는 경향이 있다.
## 1.6 단순함
- 목표를 잡기 위한 제약을 완화하는 방법은 단순함이다.
- 자료구조와 알고리즘은 먼저 잡아놓고 방법을 찾아간다.
- 좋은 해결책이란 __필요 없는 코드를 최대한 빼는 것이다.__
## 1.7 정리
- 추상화와 디커플링을 잘 활용하면 코드를 점차 쉽고 빠르게 만들 수 있다. 하지만 고민 중인 코드에 유연함이 필요없다면 추상화와 디커플링을 적용하면 안 된다.
- 개발 내내 성능을 고민하고, 최적화에 맞게 설계해야 한다. 하지만 가정을 코드에 박는 저수준의 핵심 최적화는 가능하면 늦게 하라.
- 게임 기획 내용을 확인할 수 빠르게 개발하되, 코드를 엉망으로 하면 안 된다.
- 재밌는 걸 만들고 싶다면 만드는 데에서 재미를 느껴야 한다.

# Chapter 2. 명령
> 요청 자체를 캡슐화한다. 서로 다른 사용자(client)를 매개변수로 만들고, 요청을 대기시키거나 로깅하며, 되돌릴 수 있는 연산자를 지원한다. [Gof의 디자인 패턴, p311]
- __명령 패턴은 메소드 호출을 실체화(reify)한 것이다.__
- __명령 패턴은 콜백을 객체지향적으로 표현한 것이다.__
- _실체화_ 와 _일급(first-class)_: 어떤 개념을 변수에 저장하거나 함수에 전달할 수 있도록 데이터(객체)로 바꿀 수 있는 것
- 지속 자료구조(persistent data structure): 어떤 객체를 변경하면 원래 객체는 그대로 두고 새로운 객체를 반환한다. 명령 객체마다 명령 실핼 전에 객체를 참조하고 있다가, 실행을 취소할 때 객체를 이전 객체로 되돌려주면 된다.
- 클로저를 지원하는 언어에서는 명령 패턴에 함수를 사용하여 구현할 수 있다(p54).
- 클로저(closure): 일급 객체 함수의 개념을 이용하여 스코프에 묶인 변수를 바인딩 하기 위한 일종의 기술
- [x] [명령 패턴 예제](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter2)

# Chapter 3. 경량
> 공유를 통해 많은 수의 소립(fine-grained) 객체들을 효과적으로 지원한다.[Gof의 디자인 패턴, p265]
- 객체의 개수가 너무 많아서 가볍게 사용하고 싶을 때 사용한다.
- 객체의 데이터를 두 종류로 나눈다.
  1. __고유 상태(intrinsic state), 자유문맥(context-free)__: 공유 데이터
  2. __외부 상태(extrinsic state)__: 인스턴스별로 값이 다른 데이터
- 공유 객체가 명확하지 않은 경우 경량 패턴은 잘 드러나 보이지 않는다.
## 예제
- 주로 숲에서 수많은 나무를 구현할 때 사용되는 패턴이다.
- GPU로 보내는 데이터 양을 최소화하기 위해 공유 데이터를 딱 한 번만 보내야 한다. 이후, 값이 다른 데이터들을 전달하고, GPU에게 전체 나무 인스턴스를 그릴 때 공유 데이터를 사용하도록 하면 된다.
- Direct3D, OpenGL 모두 __인스턴스 렌더링 __ 을 지원한다.
-인스턴스 렌더링을 위해서 데이터 스크림 두 개가 필요하다.
  1. 공유 데이터
  2. 다르게 보이기 위해 필요한 매개변수들
- [x] [경량 패턴 예제 지형 정보](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter3)
## 성능
  - 지형 데이터를 포인터로 접근한다는 것은 __간접 조합(indirect lookup)__ 한다는 뜻이다. 이때 캐시 미스가 발생할 수 있어 성능이 떨어질 수 있다.
  - 객체의 메모리 배치에 따라 측정되는 속도가 달라질 수 있기 때문에 확신할 수는 없다.
  - 열거형을 선언해 많은 다중 선택문을 만들기 전에 경량 패턴을 고려해봐야 한다.
## 정리
- 예제에서 인스턴스를 미리 만들었지만 필요할 때 만드는 것이 낫다. 인스턴스를 요청 받았을 때, 이전에 만들어 놓은 것을 확인하면 된다. 객체를 생성할 때 기존 객체가 존재하는지 먼저 확인할 수 있도록 생성 코드를 인터페이스 밑으로 숨겨둬야 한다. 이런 방식으로 __생성자를 숨기는 방식__ 은 Gof 팩토리 메소드 패턴의 한 예이다.
- _상태 패턴(7장)_ 을 사용할 때, 상태 기계에서 상태 객체에 멤버 변수가 하나도 없는 경우가 있다. 이때, 경량 패턴을 적용하면 상태 인스턴스 하나를 여러 상태 기계에서 동시에 __재사용__ 할 수 있다.

# Chapter 4. 관찰자
> 객체 사이에 일 대 다의 의존 관계를 정의해두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지 받고 자동으로 업데이트될 수 있게 만든다.[Gof의 디자인 패턴, p382]
- MVC(Model-View-Contoller) 구조는 관찰자 패턴을 기반으로 한다.
- 관찰자 패턴을 적용하면 어떤 코드에서 흥미로운 일이 생겼을 때 누가 받든 상관없이 알림을 보낼 수 있다.
- 목적: 코드 간의 결합을 최소화
## 예제
- 특정 기능을 담당하는 코드는 항상 한 곳에 모아두는 게 좋다.
### 관찰자
- onNotify 함수에서 아무 매개변수나 상관없지만, 보통 __알림을 보내는 객체와 다른 구체적인 정보를 담은 일반적인 데이터__ 를 매개변수로 넘긴다.
### 대상
- 알림 메소드는 __관찰당하는 객체(subject)__ 가 호출한다.
  - 대상(주체) 두 가지 임무
    1. 관찰자 목록 들고 있기(배열로)
    2. 알림 보내기
- onNotify 함수 호출 시 관찰자 목록을 건드리지 못하게 하거나 동시에 변경하더라도 문제없도록 구현하면 안전하다. 또는, 관찰자 목록을 지역 변수에 복사한 값을 대신 순회하도록 한다.
### 물리 관찰
- 남은 작업
  1. 물리 엔진에 훅(hook)을 걸어 알림을 보낼 수 있게 하는 일
  2. 업적 시스템에서 알림을 받을 수 있도록 스스로를 등록하게 하는 일
- Subject 클래스를 상속 받는 대신 Physics 클래스가 Subject 인스턴스를 포함하게 만드는 것이 좋다. 이러면 물리 엔진 자체를 관찰하기 보다는, 별도의 낙하 이벤트 객체가 대상이 된다. 관찰자는 스스로 physics.entityFell().addObserver(this);로 등록한다.
- __관찰자 시스템__ 에서는 뭔가 관심 있는 일을 하는 객체를 관찰하지만, __이벤트 시스템__ 에서는 관심 있는 일 자체를 나타내는 객체를 관찰한다.
- [x] [관찰자 패턴 예제](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter4)
## 관찰자 패턴의 단점
- 대상이 관찰자 메소드를 직접 호출하기 때문에 모든 관찰자가 알림 메소드를 반환하기 전에는 다음 작업을 진행할 수 없다. 관찰자 중 하나라도 느리면 대상이 블록될 수도 있다.
- 이벤트에 동기적(synchronous)으로 반응한다면 최대한 빨리 작업을 끝내거나 다른 스레드에게 넘기거나 작업 큐를 활용해야 한다.
- 멀티스레드, 락(lock)과 함꼐 사용 시에 교착상태에 빠지지 않도록 주의해야 한다. 엔젠에서 멀티스레드를 많이 사용한다면, 이벤트 큐(15장)을 이용해 비동기적으로 상호작용하는 것이 좋다.
- 메모리 회수(reclaim)하다 보면 동적 할당이 오래 걸릴 수 있다.
## 관찰자 연결 리스트(p77)
- Observer에 상태를 조금 추가하여 대상에 포인터 컬렉션을 따로 두지 않고, 관찰자 객체가 연결 리스트의 노드가 된다. 대상은 관찰자 연결 리스트를 포인터로 가리킨다.
- __Subject가 관리해야할 관찰자 목록은 Observer 클래스 안에 있다.__
- 같은 대상을 관찰하는 관찰자끼리 알림 순서로 인한 __의존 관계가 있어서는 안 된다.__
- 리스트 자체를 노드로 활용하기 때문에 __관찰자는 한 번에 한 대상만 관찰할 수 있다는 한계가 있다.__
## 리스트 노드 풀(p80)
- 대상이 관찰자 연결 리스트를 들고 있지만, 노드가 관찰자 객체가 아닌 __관찰자와 다음으로 가는 포인터의 데이터를 가지고 있는 노드__ 를 만든다. 이 방법을 침습성(intrusive) 연결 리스트라고 부른다. 유연함은 떨어지지만 효율은 더 좋다.
- 여러 대상을 한번에 관찰할 수 있다.
- 동적 할당을 피하는 방법은 모든 노드가 같은 자료형에 같은 크기이기 때문에 객체 풀(19장)에 미리 할당하면 된다.
## 기술적인 문제
- __대상이 죽었을 때__ , 대상이 삭제되기 직전에 마지막으로 '사망' 알림을 보내면 된다.
- __관찰자를 제거할 때__ , 대상이 관찰자를 포인터로 알고 있기 때문에 더 어렵다. 아래 두 방법은 모두 관찰자가 자기가 관찰 중인 대상들의 목록을 관리해야 하기 때문에 __상호참조__ 가 생겨 복잡성이 늘어나는 단점이 있다.
  1. __관찰자가 삭제될 때 스스로를 등록 취소__ 한다. 관찰자의 소멸자에서 대상의 removeObserver()만 호출하면 된다.
  2. __자동으로 모든 대상으로부터 등록 취소하게 만든다.__
- __GC(garbage collector)__ 가 있는 언어에도 문제가 발생한다. 상태창을 보여주는 UI를 예시로 보면, UI가 보이지 않지만 캐릭터 관찰자 목록에서 여전히 상태창 UI를 참조하고 있기 때문에 GC가 수거해 가지 않는다. 또한, 눈에 보이지 않는 UI 요소를 업데이트하느라 CPU 클럭을 낭비한다. 이를 _사라진 리스너 문제(lapsed listener problem)_ 이라고 부른다.
## 유지보수 문제
- 코드가 명시적으로 커플링되어 있으면 어떤 메소드가 호출되는지 보면 되지만, 관찰자 목록을 통해 코드가 커플링되어 있다면 _런타임_ 에서 확인해봐야 한다.
- 코드를 이해하기 위해 양쪽 코드의 상호작용을 같이 확인해야 할 일이 많다면, 관찰자 패턴 대신 두 코드를 명시적으로 연결하는 것이 낫다.
- 반대로, 모듈 같은 서로 연관 없는 코드 덩어리들이 하나의 큰 덩어리가 되지 않으면서 서로 상호작용하기에는 관찰자 패턴을 사용하는 것이 좋다.
## 오늘날의 관찰자
- 상속은 무겁고 융통성이 없다. 한 클래스가 대상 인스턴스별 알림 메소드를 다르게 정의할 수 없다.
- 최근에는 메소드나 함수 레퍼런스만으로 관찰자를 만든다.
## 미래의 관찰자
- 데이터 흐름 프로그래밍(dataflow programming), [함수형 반응형 프로그래밍(functional reactive programing)](http://goo.gl/wkerWw)는 사운드 프로세싱이나 칩 설계 같은 제한적인 분야에서 성공을 거두었다.
- __데이터 바인딩__ 은 어떤 값이 변경되면 관련된 UI나 속성을 바꿔줘야 하는 귀찮은 작업을 알아서 해준다. 게임 핵심 코드에 적용하기에는 느리고 복잡하지만, UI같이 성능에 덜 민감한 부분에 사용할 수 있을 것이다.

# Chapter 5. 프로토타입
> 원형이 되는(prototypical) 인스턴스를 사용하여 생성할 객체의 종류를 명시하고, 이렇게 만든 견본을 복사해서 새로운 객체를 생성한다.[Gof의 디자인 패턴, p169]
- 프로토타입의 클래스뿐만 아니라 상태도 같이 __복제(clone)__ 한다.
- 상속 구조가 복잡하면 유지보수가 힘들기 때문에, 요즘은 개체 종류별로 클래스를 만들기보다는 _컴포넌트(14장)_ 나 _타입 객체(13장)_ 로 모델링하는 것을 선호한다
- 클래스가 전달 가능한 일급 자료형인 동적 자료형 언어에서는 문제를 훨씬 직접적으로 풀 수 있다.
- [X] [프로토타입 패턴 예제](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter5)
## 프로토타입 언어 패러다임
- 객체지향 프로그래밍(OOP)는 데이터와 코드를 묶어주는 객체를 직접 정의할 수 있게 한다.
- OOP는 상태와 동작을 함께 묶는다.
### 클래스 기반 언어
- 상태(필드)와 동작 사이에 분명한 구별이 있다.
- 상태는 __인스턴스__ 에 있고, 동작은 __클래스__ 에 들어 있다.
- 클래스는 자기 자신의 인스턴스 생성기(factory)다.
### 셀프(p94)
- 상태와 동작 사이에 구별이 없다. 무엇이든 객체에서 바로 찾을 수 있다.
- 상속 대신 __위임(delegation)__ 개념이 있다. 레퍼런스로된 상위 객체를 찾아본다. 찾아보고 없으면 상위 객체에 위임한다.
- 객체를 만들 때 프로토타입 패턴처럼 복제를 한다.
- 비슷한 객체를 여럿 만들려면 다음과 같이 한다.
  1. 객체 하나를 원하는 상태로 만든다. 시스템에서 제공하는 기본 Object 객체를 복제한 뒤에 필드와 메소드를 채워 넣는다.
  2. 원하는 만큼 복제한다.
- 복잡한 것을 사용자에게 넘겼기 때문에 사용하기 불편하다. 많은 게임에서 캐릭터 클래스, 적, 아이템 등을 명확하게 나누고 있는 점도 포함된다.
### 자바스크립트
- 자료형을 정의하는 객체로부터 new를 호출하는 생성자 함수를 통해 객체를 생성한다.
- 상태는 인스턴스 그 자체에 저장된다.
- 동작은 자료형이 같은 객체 모두가 공유하는 메소드 집합을 대표하는 별도 객체인 프로토타입에 저장되고 위임을 통해 간접 접근된다.
- 프로토타입기반 언어인 핵심인 __복제를 찾을 수 없다.__
## 데이터 모델링을 위한 프로토타입
- __JSON__ 을 사용해 프로토타입과 위임을 활용해 데이터를 재사용할 수 있다.
- 객체에 프로토타입 필드를 넣어서 중복을 제거할 수 있다.
- 추상 프로토타입을 따로 만들지 않아도 된다.

# Chapter 6. 싱글턴
> 오직 한 개의 클래스 인스턴스만을 갖도록 보장하고, 이에 대한 전역적인 접근점을 제공합니다.[Gof의 디자인 패턴, p181]
- 한 개의 클래스 인스턴스만 갖도록 한다. 그 인스턴스를 전역에서 접근할 수 있는 메소드를 제공한다.
- 생성자를 private으로 제한한다. 정적 메소드 instatnce는 싱글턴을 실제로 필요할 때까지 인스턴스 초기화를 미룬다.
- 장점
  - 인수로 주고 받지 않아도 어디서나 접근할 수 있다.
  - 한 번도 사용하지 않는다면 아예 인스턴스를 생성하지 않는다.
  - 런타임에 초기화된다.
  - 싱글턴을 상속할 수 있다. 싱글턴 상속 기법은 단위 테스트용 모의 객체(mock object)를 만들 때도 유용하다.
## 싱글턴 패턴의 문제
- 전역 변수는 코드 이해를 어렵게 한다.
  - 순수 함수: 전역 상태에 접근하거나 수정하지 않는 함수. 이해가 쉽고 컴파일러가 쉽게 최적화할 수 있다. 메모이제이션 기법을 사용할 수 있다.
- 전역 변수는 커플링을 조장한다.
- 전역 변수는 멀티스레딩 같은 동시성 프로그래밍에 알맞지 않다.
- 한 가지 기능만 사용하려고 해도 두 가지 기능을 사용해야 한다. 예를 들어 Log 클래스를 싱글턴으로 만들 때, 하나의 파일 안에 로그를 써야 한다.
- 게임에서 게으른 초기화가 적절하지 않다.
## 대안
- 가능하면 도우미 클래스에 있던 작동 코드를 모두 원래 클래스로 옮기는 것이 낫다. 객체가 스스로 챙기게 하는 것이 OOP다.
### 오직 한 개의 클래스 인스턴스만 갖도록 보장하기
- 인스턴스가 둘 이상 되는 순간 __단언문(assert)__ 에 걸린다.
- 단일 인스턴스는 보장하지만 클래스를 어떻게 사용할지에 대해 강제하지 않는다.
- __단점__: 싱글턴은 클래스 문법을 활용해 컴파일 시간에 단일 인스턴스를 보장하지만, 이 방식은 __런타임에 인스턴스 개수를 확인__ 한다.
### 인스턴스에 쉽게 접근하기
1. __넘겨주기__
    - __의존성 주입(dependency injection)__: 매개변수로 받아 사용하는 방식
    - 어떤 객체는 메소드 시그니처에 포함되지 않는다.
2. __상위 클래스로부터 얻기__
    - Log 인스턴스 얻는 방법
      1. GameObject가 Log 인스턴스를 정적으로 생성해 들고 있기
      2. Log 객체를 얻을 수 있는 초기화 함수 제공
      3. 서비스 중개자 패턴(16장) 사용
3. __이미 전역인 객체로부터 얻기__
    - 단점
      - 더 많은 코드가 전역 클래스에 커플링 된다.
      - 객체에 접근하기 위해서 전역 클래스에 대해 알아야 한다.
    - 해결
      - 넘겨주기 사용
      - 상위 클래스로부터 얻기를 통해 접근
4. __서비스 중개자로부터 얻기__
- [X] [싱글턴 패턴 예제](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter6)
### 싱글턴 패턴 대체 패턴
- 하위 클래스 샌드박스 패턴(12장), 서비스 중개자 패턴(16장)

# Chapter 7. 상태
> 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게 허가하는 패턴으로, 이렇게 하면 객체는 마치 자신의 클래스를 바꾸는 것처럼 보인다.[Gof의 디자인 패턴, p395]
## 유한 상태 기계(FSM)
- 오토마타 이론에서 나왔다.
- __요점__
  - 가질 수 있는 __'상태'__ 가 한정된다.
  - 한 번에 '한 가지' 상태만 될 수 있다.
  - __'입력'__ 이나 '이벤트'가 기계에 전달된다.
  - 각 상태에는 입력에 따라 다음 상태로 바뀌는 __'전이(transition)'__가 있다.
## 상태 패턴
- 때로는 if문만으로 충분하다. 그러나 Heroine 예제 정도라면 상태 패턴을 쓰는 것이 낫다.
1. 상태 인터페이스
    - __상태에 의존하는 모든 코드(다중 선택문에 있던 동작)을 인터페이스의 가상 메소드로 만든다.__ 예제에서는 handleInput()과 update()가 해당된다.
2. 상태별 클래스 만들기
3. 동작을 상태에 위임하기
    - Heroin 클래스에 자신의 현재 상태 객체 포인터를 추가한다. 상태를 바꾸려면 포인터에 다른 객체를 할당하면 된다.
### 전략 패턴, 타입 객체 패턴과의 차이
- 차이점은 의도에 있다.
- 전략 패턴: 주요 클래스를 일부 동작으로부터 __디커플링__ 하는 것이 목표다.
- 타입 객체 패턴: 같은 타입 객체의 레퍼런스를 __공유__ 함으로써 __여러__ 객체를 비슷하게 동작시키는 것이 목표다.
상태 패턴: 동작을 위임하는 객체를 __변경__ 함으로써 주요 클래스의 동작을 변경하는 것이 목표다.
## 상태 객체
1. 정적 객체
    - 상태 객체에 필드가 따로 없다면 가상 메소드 호출에 필요한 vtable 포인터만 있는 셈이다. 모든 인스턴스는 같기 때문에 인스턴스는 하나만 있으면 된다.(경량 패턴)
    - 정적 인스턴스는 원하는 곳에 둔다.
    - 필드가 없고 가상 메소드도 하나밖에 없다면 상태 클래스를 정적 함수로 바꿀 수 있다.
2. 상태 객체 만들기
    - 새로 상태를 할당했기 때문에 이전 상태를 해제해야 한다. this를 스스로 지우지 않도록 주의해야 한다.
## 입장과 퇴장
- 상태에서 그래픽까지 제어하는 것이 바람직하다.
- 새로운 상태로 교체됐을 때 입장 기능을 사용한다. 입장 기능 한곳에 코드를 모아둘 수 있다.
- 새로운 상태로 교체되기 직전에 퇴장 코드를 추가할 수도 있다.
## FSM 단점
- 미리 정해놓은 여러 상태와 현재 상태 하나, 하드코딩되어 있는 전이만 존재한다.
- 상태 기계를 인공지능 같은 복잡한 곳에 적용하기에 한계가 있다. __튜링 완전(Turing complete)하지조차 않다.__
### 병행 상태 기계
- 무엇을 하는가에 대한 상태 n개와 무엇을 들고 있는가에 대한 상태 m을 한 상태 기계에 욱여넣으면 __n*m__ 개 상태가 필요하다. 상태 기계를 둘로 나누면 __n+m__ 개 상태만 있으면 된다.
- 상태를 각각 참조한다. 상태에 위임할 때는 상태 기계 양쪽에 다 전달한다.
- 첫 번째 상태 기계에서 입력을 씹어서(consume) 다음 상태 기계까지 입력이 가지 않도록 할 수 있다.
- __단점__ : 어떤 상태 코드에서 다른 상태 기계의 상태가 무엇인지 검사하는 지저분한 코드를 만드는 일이 생길 수도 있다.
### 계층형 상태 기계
- 단순 상태 기계에서는 모든 상태마다 코드를 중복해서 넣어야 한다. 상속으로 여러 상태가 코드를 공유할 수 있다.
- 어떤 상태는 __상위 상태(superstate)__ 를 가질 수 있고, 그 경우 그 상태 자신은 __하위 상태(substate)__ 가 된다.
- 이번트가 들어올 때 하위 상태에서 처리하지 않으면 상위 상태로 넘어간다.
- 클래스를 사용하는 Gof식 상태 패턴을 쓰지 않는다면, 클래스에 상태를 하나만 두지 않고 상태 스택을 만들어 명시적으로 현재 상태의 상위 상태 연쇄를 모델링할 수도 있다.
### 푸시다운 오토마타
- FSM에는 __이력__ 개념이 없다는 문제가 있다.
- FSM은 이전 상태를 덮어쓴다면, 푸시다운 오토마타는 __상태 스택__ 을 사용한다.
## FSM 유용함
- 요즘 게임 AI는 행동 크리나 계획 시스템을 더 많이 쓰는 추세이기 때문에 FSM만으로는 한계가 있다.
- 다음과 같을 때 FSM을 사용하면 좋다.
    - 내부 상태에 따라 객체 동작이 바뀔 때
    - 이런 상태가 그다지 많지 않은 선택지로 분명하게 구분될 수 있을 때
    - 객체가 입력이나 이벤트에 따라 반응할 때
- [X] [상태 패턴 예제](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter7)

# Chapter 8. 이중 버퍼
- 의도: 여러 순차 작업의 결과를 한 번에 보여준다.
- 렌더링 도중에 나타나는 __테어링__ 을 해결하기 위해 만들었다.
- __테어링__: 코드에 픽셀 값을 입력하는 동안 비디오 드라이버도 프레임버퍼를 읽기 시작한다. 결국에는 렌더러가 입력하는 픽셀을 앞질러 입력되지 않은 픽셀까지 읽어 들인다. 렌더러는 버퍼에 값을 다 그렸지만 드라이버는 새로 추가된 픽셀을 읽지 않는다. 결과적으로 그림은 반만 그려진다.
- 프레임버퍼를 __두 개__ 준비하여 하나의 버퍼에는 지금 프레임에 보일 값을 둬서 GPU가 원할 때 언제든지 읽을 수 있게 한다. 그동안 렌더링 코드는 다른 프레임 버퍼를 채운다. 버퍼를 교체한 뒤 비디오 하드웨어에 지금부터 두 번째 버퍼를 읽으라고 알려준다.
## 패턴
- __버퍼 클래스__ 는 변경이 가능한 상태인 버퍼를 __캡슐화__ 한다. 버퍼 클래스는 현재 버퍼와 다음 버퍼, 두 개의 버퍼를 갖는다.
- 정보를 읽을 때는 항상 __현재__ 버퍼에, 정보를 쓸 때는 항상 __다음__ 버퍼에 접근한다. 변경이 끝나면 다음 버퍼와 현재 버퍼를 교체해 다음 버퍼가 보여지게 한다. 현재 버퍼는 새로운 다음 버퍼가 되어 재사용된다.
- 이중 버퍼 패턴은 다음과 같은 상황에 적합하다.
    - 순차적으로 변경해야 하는 상태가 있다.
    - 이 상태는 변경 도중에도 접근 가능해야 한다.
    - 바깥 코드에서는 작업 중인 상태에 접근할 수 없어야 한다.
    - 상태에 값을 쓰는 도중에도 기다리지 않고 바로 접근할 수 있어야 한다.
### 주의사항
- __교체 연산 자체에 시간이 걸린다.__
    - 교체 연산은 _원자적(atomic)_ 이어햐 한다. 버퍼에 쓰는 값보다 교체가 더 오래 걸리면 안 된다.
- __버퍼가 두 개 필요하다.__
    - 메모리가 부족한 기기에서 부담이 될 수 있다. 이중 버퍼 패턴을 포기하고 상태를 변경하는 동안 밖에서 접근하지 못하게 할 방법을 찾아여 한다.
### 그래픽스 외의 활용법
- __변경 중인 상태에 접근할 수 있다__ 는 문제를 해결하기 위해 이중 버퍼 사용
- __문제 원인__
    1. 다른 스레드나 인터럽트(interrupt)에서 상태에 접근하는 경우: 그래픽스 예제
    2. __어떤 상태를 변경하는 코드__ 가 동시에 지금 변경하려는 상태를 읽는 경우: 물리나 인공지능같이 객체가 서로 상호작용할 때
- 예제처럼 업데이트 순서에 따라 결과가 다르면 안 된다.
### 디자인 결정
- 구현할 때 결정해야 할 중요한 점 두 가지
#### __버퍼를 어떻게 교체할 것인가?__
- 버퍼 교체 연산은 읽기 버퍼와 쓰기 버퍼 모두를 사용하지 못하게 한다. 최고 성능을 얻기 위해 빠르게 교체해야 한다.
1. 버퍼 포인터나 레퍼런스를 교체
    - 그래픽스 예제에서 봐던 방식으로 이중 버퍼 그래픽스에서 가장 일반적으로 사용된다.
    - 특징
      + 빠르다
      + 버퍼 코드 밖에서는 버퍼 메모리를 포인터로 저장할 수 없는 한계가 있다.
      + 버퍼에 남아 있는 데이터는 바로 이전 프레임 데이터가 아닌 2프레임 전 데이터다.
2. 버퍼끼리 데이터를 복사
    - 슬랩스틱 코미디언 예제에 사용됐다.
    - 특징
      + 다음 버퍼에는 딱 한 프레임 전 데이터가 들어 있다.
      + 교체 시간이 더 걸린다.
#### __얼마나 정밀하게 버퍼링할 것인가?__
- 버퍼가 어떻게 구성되어 있는가를 생각해야 한다.
- 버퍼가 __하나의 큰 데이터 덩어리__ 이면 그래픽 예제에 해당되고, __객체 컬렉션 안에서 분산__ 되어 있으면 배우 예제에 해당된다.
1. 버퍼가 한 덩어리라면
    - 간단히 교체할 수 있다. 버퍼 두 개를 한 번에 맞바꾸기만 하면 된다.
2. 여러 객체가 각종 데이터를 들고 있다면
    - 교체가 더 느리다. 전체 객체 컬렉션을 순회해야 한다.
    - 이전 버퍼를 건들지 않아도 된다면, 단일 버퍼와 같은 성능을 내도록 최적화할 방법이 있다. 현재와 다음 포인터 개념을 객체 상대적 오프셋으로 응용하는 데 있다.
- [X] [이중 버퍼 패턴 예제](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter8)

# Chapter 9. 게임 루프
- 의도: 게임 시간 진행을 유저 입력, 프로세서 속도와 디커플링한다.
- _배치 모드(batch mode)_ 프로그램: 모든 작업이 끝나면 멈추는 프로그램
- 대화형(interactive) 프로그램: 즉각적인 피드백을 해주는 프로그램
- GUI 프로그램: 문자 입력 대신 마우스나 키보드 __입력 이벤트__ 를 기다리는 프로그램
- 위의 프로그램들은 사용자 __입력__ 을 받을 때까지 멈춰있다.
- __게임은 유저 입력이 없어도 계속 돌아간다.__
- __어떤 하드웨어에서도 일정한 속도로 실행__ 될 수 있게 해야 한다.
```
// 게임 루프
while(true) {
  processInput()  // 유저 입력 처리
  update()        // AI와 물리 처리
  render()        // 게임 화면 처리(그리기)
}
```
- 게임 월드에서의 시간
    - _초당 프레임 수(Frames Per Second)_: 실제 시간 동안 게임 루프가 얼마나 많이 돌았는지 측정
    - __프레임 레이트(frame rate) 결정 요인__
      1. 한 프레임에 얼마나 많은 작업을 하는가
      2. 코드가 실행되는 플랫폼의 속도
## 패턴
- 게임 루프는 게임 내내 실행된다. 멈춤 없이 __유저 입력을 처리__ 한 뒤 __게임 상태를 업데이트__ 하고 __게임 화면을 렌더링__ 한다. 시간 흐름에 따라 게임 플레이 속도를 조절한다.
- 주의사항: 게임 루프 코드는 최적화를 고려해 깐깐하게 만들어야 한다.
- 그래픽 UI, 이벤트 루프가 있는 OS, 플랫폼에서 게임을 만들 경우는 애플리케이션 루프가 _두 개_ 있는 셈이므로 서로 잘 맞춰야 한다.(p166)
### 한 번은 짧게, 한 번은 길게
#### 첫 번째 문제
1. 업데이트할 때마다 정해진 만큼 게임 시간이 진행된다.
2. 업데이트하는 데에는 현실 세계의 시간이 어느 정도 걸린다.
- 2번이 1번보다 오래 걸리면 게임은 _느려진다._
- __해결__: 프레임 이후로 실제 시간이 얼마나 지났는지에 따라 시간 간격을 조절하면 된다.( _가변 시간 간격, 유동 시간 간격_ )
    1. 매 프레임 마다 이전 게임 업데이트 이후 실제 시간이 얼마나 지났는지 elapsed에 저장한다.
    2. 게임 상태를 업데이트할 때마다 elapsed를 같이 넘겨주면 받는 쪽에서는 지난 시간만큼 게임 월드 상태를 진행한다.
    - 예시: 시간 간격이 커지면 총알을 더 많이 움직인다.
    - __장점__
      + 다양한 하드웨어에서 비슷한 속도로 게임이 돌아간다.
      + 더 빠른 하드웨어를 사용하는 유저는 더 부드러운 게임 플레이를 즐길 수 있다.
#### 두 번째 문제
- 첫 번째 방식을 사용하면 게임이 __비결정적__ 이자 __불안정__ 하게 된다.
    - _결정적_: 프로그램을 실행할 때마다 입력이 같으면 결과도 정확하게 같다는 뜻(p169)
- 보통 게임에서는 부동 소수점을 쓰기 때문에 __반올림 오차__ 가 발생한다.
- 실시간으로 실행하기 위해 게임 물리 엔진은 실제 물리 법칙의 근사치를 취한다. 근사치가 튀는 걸(blowing up) 막기 위해 _감쇠(damping)_ 을 적용하는 데, __가변 시간 간격에서 이 감쇠 값이 바뀌다보면 물리가 불안정해진다.__
### 따라잡기
- 가변 시간 간격에 영향을 받지 않는 부분 중 하나가 __렌더링__이다.
- __고정 시간 간격으로 업데이트 하지만 렌더링 간격은 유연하게 만들어 프로세서 낭비를 줄인다.__
- 원리
    1. 이전 루프 이후로 실제 시간이 얼마나 지났는지 확인
    2. _게임_ 의 현재가 _실제 시간_ 의 현재를 따라잡을 때까지 __고정__ 시간 간격만큼 게임 시간을 __여러 번__ 시뮬레이션한다.
- 예제
    1. 프레임을 시작할 때마다 실제 시간이 얼마나 지났는지를 lag 변수에 저장한다.
    2. 고정 시간 간격으로 루프를 돌면서 실제 시간을 따라잡을 때까지 게임을 업데이트한다.
    3. 다 따라잡은 후에 렌더링한다.
- 시간 간격(MS_PER_FRAME)은 더 이상 시각적 프레임 레이트가 아닌 게임을 얼마나 촘촘하게 업데이트할지에 대한 값이다.
- 시간 간격을 60FPS보다 더 빠르게 충분히 짧게 만드는 것이 좋지만 __너무 짧아지지 않도록 주의해야 한다__. 가장 느린 하드웨어에서도 update()를 실행하는 데 걸리는 시간보다는 시간 간격이 커야 한다.
### 중간에 끼는 경우
- 유저 입장에서 두 업데이트 사이에 렌더링되는 경우가 종종 있다. __항상 업데이트 후에 렌더링되는 것은 아니다.__
- __해결__: 다음 프레임까지 남은 시간(lag)가 0이 아니고 업데이트 시간 간격보다 적을 때는 업데이트 루프를 빠져나온다.
- 렌더러는 게임 객체들과 각각의 현재 속도를 안다.
- 렌더링에서 현재 프레임에서의 위치와 다음 프레임에서의 _예상_ 위치를 이용해 위치를 보간한다. 보간은 추측이기 때문에 틀릴 수 있지만, 이런 __위치 보간은 그다지 눈에 띄지 않는다.__
## 디자인 결정
- 화면 재생 빈도(refresh rate), 동기화, 멀티스레딩, GPU까지 고려하면 실제 게임 루프 코드를 훨씬 복잡해질 수 있다.
### 게임 루프를 직접 관리하는가, 플랫폼이 관리하는가?
- 웹 브라이저용이나 기존 게임 엔진에서는 루프를 직접 만들 가능성을 _거의_ 없다.
#### 플랫폼 이벤트 루프 사용
- 간단하다.
- 플랫폼에 잘 맞는다.
- 시간을 제어할 수 없다. 부드럽게 호출되지 않으면 문제가 된다.
#### 게임 엔진 루프 사용
- 코드를 직접 작성하지 않아도 된다.
- 코드를 직접 작성할 수 없다.
#### 직접 만든 루프 사용
- 완전한 제어, 개발하는 게임에 딱 맞게 설계할 수 있다.
- 플랫폼과 상호작용해야 한다. 프레임워크에 시간이 주어지지 않을 수 있다. 이럴 때 프레임워크가 행(hang)되지 않도록 가끔 제어권을 넘겨줘야 한다.
### 전력 소모 문제
- 스마트폰, 노트북, 모바일 게임 시대가 되면서 CPU를 가능한 적게 쓸 방법을 고민해야 한다.
- 한 프레임에 해야할 작업이 끝나면 __CPU를 쉬게 해줘야__ 하는 성능 상한이 있는 셈이다.
#### 최대한 빨리 실행하기
- 주로 PC 게임에서 실행한다.
- 게임 루프에서 OS에 따로 __sleep을 호출하지 않는다.__ 대신 남는 시간에 FPS나 그래픽 품질을 더 높인다.
- 전력을 최대한 많이 사용한다.
#### 프레임 레이트 제한하기
- 모바일 게임은 그래픽 품질보다 __게임 플레이 품질에 더 집중하는 편이다.__
- 프레임 레이트에 상한(30FPS 또는 60FPS)을 두는 게 보통이다.
- 프레임 시간 안에 할 일이 끝나면 나머지 시간 동안 sleep을 호출한다.
### 게임 플레이 속도는 어떻게 제어할 것인가?
- __게임 루프 핵심 요소__: 비동기 유저 입력, 시간 따라잡기
- 다양한 플랫폼을 어떻게 지원하느냐가 핵심이다.
#### 동기화 없는 고정 시간 간격 방식
- 맨 처음 본 예제 코드 방식이다. 게임 루프를 최대한 빠르게 실행한다.
- 특징
    - 간단하다
    - 게임 속도는 하드웨어와 게임 복잡도에 바로 영향을 받는다.
#### 동기화하는 고정 시간 간격 방식
- 고정 시간 간격으로 게임을 실행하되, 루프 마지막에 지연이나 동기화 지점을 넣어서 게임이 너무 빨리 실행되는 것을 막는다.
- 특징
    - 그래도 간단한 편이다.
    - 전력 효율이 높다.
    - 게임이 너무 빨라지진 않는다.
    - 게임이 너무 느려질 수 있다.
#### 가변 시간 간격 방식
- 너무 느리거나 너무 빠른 곳에서도 맞춰서 플레이할 수 있다.
- __게임 플레이를 불안정하고 비결정적으로 만든다.__
#### 업데이트는 고정 시간 간격으로, 렌더링은 가변 시간 간격으로
- 너무 느리거나 너무 빨라도 잘 적응한다.
- 훨씬 복잡하다.
## 관련자료(p176)
- 글렌 피들러의 'fix your timestep'
- 쿤 비터르스의 'dewitters gameloop'
- 'monobehaviour lifecycle'


# Chapter 10. 업데이트 메서드
- 의도: 컬렉션에 들어 있는 객체별로 한 프레임 단위의 작업을 진행하라고 알려줘서 전체를 시뮬레이션한다.
- 이전처럼 작성하면 코드의 유지보수가 힘들어진다. 
- 해결: __모든 개체가 자신의 동작을 캡슐화__ 하면 된다. 이때 추상 메소드인 update()를 정의해 __추상 계층__ 을 더한다.
- 정확한 자료형은 모르는 채로 객체 컬렉션을 관리한다. 매 프레임마다 객체 컬렉션을 돌면서 update()를 호출한다. 덕분에 모든 게임 객체가 동시에 동작한다. 게임 루프에는 객체를 관리하는 동적 컬렉션이 있다.
## 패턴
- __게임 월드__ 는 객체 컬렉션을 관리한다. 각 객체는 __한 프레임 단위의 동작을 시뮬레이션하기 위한 __업데이트 메서드(메소드)__ 를 구현한다. 매 프레임마다 컬렉션에 있는 모든 객체를 업데이트한다.
- __따로 구현하지 않아도 개체를 게임에 추가할 수 있게 해준다.__ 덕분에 데이터 파일이나 레벨 에디터 같은 걸로 월드에 개체를 유연하게 추가할 수 있다.
### 언제 쓸 것인가?
- 게임이 더 추상적이거나 게임에서 움직이는 것들이 _체스 말_ 에 가깝다면 __업데이트 메서드가 맞지 않을 수 있다.__ 그러나 애니메이션은 매 프레임 업데이트해야 하기 때문에 이 패턴이 도움될 수 있다.
- 업데이트 메서드는 아래와 같을 때 __사용__ 할 수 있다.
    - 동시에 동작해야 하는 객체나 시스템이 게임에 많다.
    - 각 객체의 동작은 다른 객체와 거의 독립적이다.
    - 객체는 시간의 흐름에 따라 시뮬레이션되어야 한다.
### 주의사항
#### 코드를 한 프레임 단위로 끊어서 실행하는 게 더 복잡하다.
#### 다음 프레임에서 다시 시작할 수 있도록 현재 상태를 저장해야 한다.
- 코드가 반환되고 나면 이전 실행 위치를 알 수 없기 때문에 상태 패턴(7장)을 사용하는 것도 좋다.
#### 모든 객체는 매 프레임마다 시뮬레이션되지만 진짜로 동시에 되는 건 아니다.
- 객체 업데이트 __순서__ 가 중요하다. 순차적으로 동작하지 않게 하려면 이중 버퍼 패턴(8장) 같은 게 필요하다.
- 게임 월드가 유효한 상태를 유지하면서 업데이트할 때마다 __점진적으로 바꿔나가면 상태가 꼬이지 않아 중재할 게 없다.__ 또한 여러 이동을 직렬화해서 네트워크로 전송할 수 있으므로 온라인 게임 만들기에도 좋다.
#### 업데이트 도중에 객체 목록을 바꾸는 건 조심해야 한다.
- __추가__
    - 문제: 새로 생성된 객체가 스폰된 걸 플레이어가 볼 틈도 없이 해당 프레임에서 작동하게 된다.
    - 해결: 업데이트 루프를 시작하기 전에 목록에 있는 객체 개수를 미리 저장해놓고 그만큼만 업데이트하면 된다.
- __삭제__
    - 문제: 의도치 않게 객체 하나를 건너뛸 수 있다.
    - 해결: 객체를 삭제할 때 순회 변수 i를 업데이트하거나 __목록을 다 순회할 때까지 삭제를 늦추는 수도 있다.__ 만약 멀티스레드가 돌고 있다면 업데이트 도중에 비싼 스레드 동기화를 피하기 위해 후자를 선택해야 한다.
### 예제 코드
- 상속을 사용하기보다 컴포넌트 패턴(14장)을 사용하는 것이 좋다. 컴포넌트 패턴을 사용하면 __update() 함수는 개체 클래스가 아닌 개체 객체의 컴포넌트에 있게 된다.__
- [X] [업데이트 메서드 예제 코드](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter10)
#### 시간 전달
- 가변 시간 간격을 쓰는 게임은 update()에 지난 시간을 인수로 전달한다.
## 디자인 결정
### 업데이트 메서드를 어느 클래스에 둘 것인가?
#### 개체 클래스
- 개체의 종류가 많지 않다면 괜찮지만, __요즘 업계는 이 방식을 멀리하고 있다.__
- 새로운 동작을 만들 때마다 개체 클래스를 상속받아야 한다면 코드가 망가지기 쉽고 작업하기가 어렵다.
#### 컴포넌트 클래스
- 컴포넌트는 알아서 자기 자신을 업데이트한다.
- 컴포넌트 패턴은 __한 개체의 일부를 개체의 다른 부분들과 디커플링한다.__ 렌더링, 물리, AI는 스스로 알아서 돌아간다.
#### 위임 클래스
- 상태 패턴(7장), 타입 객체 패턴(13) 중에 하나를 쓴다면 위임 클래스에 update를 두는 것이 자연스럽다.
- 여전히 update() 메서드는 개체 클래스에 있지만 __가상 함수가 아니며 아래와 같이 위임 객체에 포워딩(forward)만 한다.__
```
void Entity::update() {
  // 상태 객체에 포워딩한다.
  state_->update();
}
```
- 새로운 동작을 정의하고 싶다면 위임 객체를 바꾸면 된다.
### 휴면 객체 처리
- 사용 불능 상태이거나 화면 밖에 있거나 잠금 상태이거나 __일시적으로 업데이트가 필요 없는 객체가 생길 수 있다.__ 이때 순회하면서 CPU 클럭과 데이터 캐시를 낭비하게 된다.
- __해결__: 업데이트가 필요한 살아 있는 객체만 따로 컬렉션에 모아둔다.
- 얼마나 많은 객체가 비활성 상태로 남아 있는가에 따라 방법을 결정하면 된다.
#### 비활성 객체가 포함된 컬렉션 하나만 사용할 경우
- 시간 낭비한다.
#### 활성 객체만 모여 있는 컬렉션을 하나 더 둘 경우
- 두 번째 컬렉션을 위해 메모리를 추가로 사용해야 한다. 
    - 나머지 하나에 전체 객체가 아닌 비활성 객체만 모아두는 방법이 있다.
- 컬렉션 두 개의 동기화를 유지해야 한다.

# Chapter 11. 바이트코드
- 의도: 가상 머신 명령어를 인코딩한 데이터로 행동을 표현할 수있는 유연함을 제공한다.
- 게임은 출시된 뒤에도 업데이트를 통해서 버그를 고치거나 컨텐츠를 추가할 수 있어야 한다. 하드코딩하면 안 된다.
## 인터프리터 패턴
> (1 + 2) * (3 - 4)
- 이런 표현식을 읽어서 언어 문법에 따라 각각 객체로 변환한다.
- 숫자 상수는 단순히 숫자 값을 래핑한 객체다. 연산자도 객체로 바뀌는데, 이때 피연산자도 같이 참조된다. 괄호와 우선순위까지 고려하면 표현식을 객체 트리로 바꿀 수 있다. 즉, 표현식을 __파싱한다.__
- __파싱(parsing)__: 파서는 문자열을 읽어서 이를 문법 구조를 표현하는 객체 집합인 _추상 구문 트리_ 로 만든다.
- 인터프리터 패턴의 __목적__: 추상 구문 트리를 만든 뒤에, 진짜 객체지향 방식으로 표현식이 자기 자신을 평가하게 한다.
- 방법
    1. 모든 표현식 객체가 상속받을 상위 인터페이스를 만든다.
    2. 모든 표현식마다 상위 인터페이스를 상속받는 클래스를 정의한다.
    3. 복잡한 표현식은 자기를 평가하기 전에 먼저 포함된 하위표현식을 재귀적으로 평가한다.
- __단점__
    - 코드를 로딩하면서 작은 객체를 엄청 많이 만들고 연결해야 한다.
    - 객체를 잇는데 __많은 메모리가 소모된다.__
    - 포인터를 따라서 하위표현식에 접근해야 하기 때문에 데이터 캐시에 치명적이다. 또한, 가상 메서드를 호출하는 것은 명령어 메모리(instruction cache)에 치명적이다.
   - __매우 느리다.__
## 가상 기계어
- 장점
    1. 밀도가 높다.
    2. 선형적이다.
    3. 저수준이다.
    4. 빠르다.
- __단점__: 보안에 취약하다.
### 인터프리터 패턴의 안정성과 기계어의 성능을 절충한 방법
- __가상 기계어를 정의하여 이를 실행하는 에뮬레이터를 만든다.__
- 에뮬레이터: 가상머신(VM)
- 가상 바이너리 기계어: 바이트코드
## 패턴
1. **명령어 집합** 은 실행할 수 있는 저수준 작업들을 정의한다.
2. 명령어는 **일련의 바이트** 로 인코딩된다.
3. **가상 머신** 은 **중간 값들을 스택에 저장** 해가면서 이들 명령어를 하나씩 실행한다.
4. 명령어를 조합함으로써 복잡한 고수준 행동을 정의할 수 있다.
### 언제 쓸 것인가?
- 정의할 행동은 많은데 다음과 같은 이유로 구현하기 어려울 때 바이트코드 패턴을 사용한다.
    - **언어가 너무 저수준** 이라 만드는 데 손이 많이 가거나 오류가 생기기 쉽다.
    - 컴파일 시간이나 다른 빌드 환경 때문에 __반복 개발하기가 너무 오래 걸린다.__
    - __보안에 취약하다.__ 정의하려는 행동이 게임을 깨먹지 않게 하고 싶다면 나머지 코드부터 격리해야 한다.
- __바이트코드는 네이티브 코드보다는 느리므로 성능이 민감한 곳에는 적합하지 않다.__
### 주의사항
- 되는 대로 만들면 규모가 너무 커진다. 바이트코드가 표현할 수 있는 범위라도 꼼꼼히 관리해야 한다.
#### 프론트엔드가 필요하다.
- 바이너리 바이트코드 형식은 사용자가 작성할 만한 게 아니다.
- **컴파일러** 가 필요하다.
#### 디버거를 사용할 수 없다.
### 예제 코드
- API가 데이터에서 제어 가능한 것으로 단계별로 바꾼다.
#### 마법 명령어 집합
- 매개변수부터 전부 제거한다.
- 마법을 데이터로 인코딩하기 위해 열거형 값을 배열에 저장한다.
- 인터프리터는 코드와 데이터를 연결한다.
- 이때 이 가상 머신은 전혀 유연하지 않다.
#### 스택 머신
- CPU처럼 **스택** 을 이용해서 명령어 실행 순서를 제어한다.
- 명령어들은 스택을 통해서 데이터를 주고 받는다.
- 바이트코드 스트림에서 옆에 있는 바이트를 숫자로 읽어서 스택에 집어넣는다.
- _p211 그림 참고_
- 여전히 코드보다 데이터 같아 보인다.
- __기획자는 숫자만이 아니라 규칙으로 마법을 표현할 수 있기를 원한다.__
#### 행동 = 조합
- 바이트코드가 좀 더 행동을 표현할 수 있게 하려면 **조합** 을 할 수 있어야 한다.
- 스탯을 얻어오는 명령을 추가한다.
- __스탯을 읽어와 다시 스택에 넣는다.__
- 계산 능력을 넣기 위해 아래와 같이 __결과를 스택에 집어넣는다.__
```
case INST_ADD: {
  int b = pop();
  int a = pop();
  push(a + b);
  break;
}
```
- 직접 계산하는 과정은 _p214 참고_
#### 가상 머신
- 스택 크기를 통해 VM 메모리 사용량을 조절할 수 있다.
- VM이 **시간** 을 얼마나 쓸지도 제어할 수 있다. interpret() 반복문에서 실행되는 명령어가 일정 개수 이상이면 빠져나오게 할 수 있다. 그러나 지금 만들 바이트코드가 튜링이 완전하지 않아 실행시간을 제어하지 않고 __실행할 바이트코드 크기만 제어하면 된다.__
- 이제 실제로 바이트코드를 만드는 문제만 남았다.
#### 마법 제작 툴
- 지끔까지는 C++보다 저수준 시스템을 만들었다. 따라서 사용성을 좋게 해줄 **툴** 이 필요하다.
- __툴을 이용하여 마법에 대한 행동을 고수준으로 정의하고, 이를 저수준인 스택 머신 바이트코드로 변환할 수 있어야 한다.__
- __그래픽 인터페이스(GUI)_ 로 행동을 정의할 수 있는 툴을 사용하면 좋다. GUI 툴에서는 사용자가 잘못된 코드를 만들 수 없다.
- 바이트코드 패턴의 궁궁적인 목표는 __사용자가 행동을 고수준 형식으로 편하게 표현할 수 있도록 하는 데 있다.__
## 디자인 결정
- 바이트코드 VM은 보통 _스택 기반_ 과 _레지스터 기반_ 으로 나뉜다.
- __스택 기반 VM을 쓰는 것이 좋다.__ 
    - 이유: 구현이 쉽고 코드 생성이 간단하다. 레지스터 기반은 명령어를 어떻게 만드느냐, VM을 어떻게 구현하느냐에 따라 속도가 달라진다.
#### 스택 기반
- 항상 스택 위만 접근한다.
- 특징
    - 명령어가 짧다. 모든 명령어 들이 암시적으로 스택 맨 위에서 얻기 때문이다.
    - 코드 생성이 간단하다.
    - 명령어 개수가 많다.
#### 레지스터 기반
- 스택이 있지만, 바이트코드에 인덱스가 두 개 들어 있어서 스택 어디서나 읽어올 수 있다.
- 특징
    - 명령어가 길다. 명령어가 스택 오프셋 값을 인수로 들고 있기 때문에 비트가 더 많이 필요하다.
    - 명령어 개수는 줄어든다. 성능 향상을 기대할 수 있다.
### 어떤 명령어를 만들어야 하는가?
- 명령어 집합은 바이트코드로 할 수 있는 일의 범위를 결정하고, VM의 성능에 큰 영향을 미친다.
- 다음은 필요한 명령어 종류들이다.
#### 외부 원시명령
- VM 외부 게임 코드에 접근하고, 유저가 볼 수 있는 일들을 처리한다.
- 바이트코드로 어떤 행동을 표현할 수 있는지를 제어한다.
- 이 명령어가 없다면 VM은 __CPU 공회전(engine idling) 외에는 할 수 있는 게 없다.__
#### 내부 원시명령
- 리터럴, 연산, 비교, 그 외 스택에 값을 주고받는 명령어들로 __VM 내부 값을 다룬다.__
#### 흐름 제어
- 명령어를 조건에 따라 실행하거나 여러 번 **반복** 하고 싶다면 필요하다.
- 바이트코드 같은 저수준 언어에서 _흐름 제어_ 는 그냥 **점프** 를 쓰면 된다. 점프 명령어가 하는 일은 goto문과 같다.
- 반복문 명령어에는 어느 바이트코드를 실행하고 있는지를 기록하는 인덱스 변수가 있다.
#### 추상화
- 데이터를 재사용하기 위해 프로시저를 호출한다.
- 점프와 차이점: VM이 별도의 **반환 스택** 을 관리한다.
- 호출 명령을 만나면 현재 실행 인덱스를 반환 스택에 넣고 호출된 바이트코드로 점프한다. 반환(return) 코드에 도달하면 VM은 반환 스택으로부터 실행 인덱스를 받아서 그 위치로 점프한다.
### 값을 어떻게 표현할 것인가?
- 자료형을 내부적으로 어떻게 저장할지를 결정해야 한다.
#### 단일 자료형
- 간단하다. 태깅이나 변환, 자료형 검사 같은 걸 신경 쓰지 않아도 된다.
- 다른 자료형을 다룰 수 없다.
#### 태그 붙은 변수
- _동적 자료형 언어_ 에서 흔한 방식으로 모든 값은 두 부분으로 나뉜다.
- 앞에는 어떤 자료형을 저장했는지를 열거형을 이용해 자료형 태그로 표시한다. 나머지 비트는 다음과 같은 식으로 자료형에 따라 적당하게 해석된다.
```
enum ValueType
{
  TYPE_INT,
  TYPE_DOUBLE,
  TYPE_STRING
};
struct Value
{
  ValueType type;
  union
  {
    int intValue;
    double doubleValue;
    char* stringValue;
  };
};
```
- 특징
    - 값이 자신의 자료형을 안다. 지원하지 않는 타입에 대한 연산을 막을 수 있다.
    - 메모리가 더 필요하다.
#### 태그가 붙지 않은 공용체
- 앞에서처럼 공용체(union)를 사용하되, __자료형 태그는 따로 없다.__
- 데이터 비트만 봐서 어떤 자료형인지 알 수 없기 때문에 알아서 해석해야 한다.
- _정적 자료형 언어_ 에서 흔히 볼 수 있다. 컴파일할 때 타입 시스템이 값을 제대로 해석하도록 보장한다.
- 특징
    - 작다. 값만 비트로 저장했다.
    - 빠르다. 런타임에 타입을 검사하느라 클럭을 낭비하지 않아도 된다.
    - 안전하지 않다. 해킹에 노출되거나 크래시를 발행시킬 수 있다.
#### 인터페이스
- 객체지향에서 여러 자료형 중에 무엇인지 모르는 값이 있으면 다형성으로 처리한다.
- 여러 자료형을 테스트하고 변환하는 가상 메서드를 다음과 같이 제공한다.
```
class Value {
public:
  virtual ~Value() {}
  virtual ValueType type() = 0;
  virtual int asInt()
  {
    // 이 가상 함수는 정수형에서만 호출해야 한다.
    assert(false);
    return 0;
  }
  // 다른 변환 메서드들
};
// 구체 클래스
class IntValue : public Value {
public:
  IntValue(int value) : value_{value} {}

  virtual ValueType type() { return TYPE_INT; }
  virtual int asInt() {return value_;}
private:
  int value_;
};
```
- 특징
    - 제한이 없다
    - 객체지향적이다.
    - 번거롭다.
    - __비효율적이다.__ 다형성은 포인터를 통해서 작동하기 때문에 불리언이나 숫자 같은 단순한 값도 힙에 할당된 객체로 래핑해야 한다. 인터프리터 패턴을 기피하는 문제들도 거의 그대로 남아 있다.
### 바이트코드는 어떻게 만들 것인가?
- 보통은 컴파일러를 만들지만 다른 방법도 있다.
#### 텍스트 기반 언어를 정의할 경우
- 문법을 정의해야 한다.
- 파서를 구현해야 한다. 파서 생성기를 이용하거나 _재귀 하향 파서(recursive descent parser)_ 를 직접만들면 된다.
- 문법 오류를 처리해야 한다.
- 비-프로그래머들은 쓰기 어려울 것이다.
#### UI가 있는 저작 툴을 만들 경우
-UI를 구현해야 한다.
- 오류가 적다.
- 이식성이 낮다. 많은 프레임워크가 특정 OS에 종속되어 있다.
## 관련자료
- 이 패턴은 GoF의 인터프리터 패턴과 형제 관계로 __둘다 데이터로 행동을 조합할 수 있는 방법을 제공한다.__
- 사실 두 패턴을 다 사용하는 경우가 많다.
- 두 패턴의 **유일한 차이점** 은 행동 관련 코드를 바로 실행하지 않고 나중에 실행할수 있도록 바이트코드 명령어로 출력한다는 것뿐이다.
- 루아 프로그래밍 언어는 레지스터 기반 바이트코드 VM으로 간결하게 구현되어 있다.
- 키즈멧(Kismet)은 그래픽 스크립트 툴이다.
- [X] [바이트코드 예제](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter11)

# Chapter 12. 하위 클래스 샌드박스
- 의도: 상위 클래스가 제공하는 기능들을 통해서 하위 클래스에서 행동을 정의한다.
- 하위 클래스가 많아질 거 같으면, 하드코딩보다 데이터 기반으로 구현하는 것이 낫다. 타입 객체(13장), 바이트코드(11장) 등을 참고.
- __문제__
    - 중복 코드가 많아진다.
    - 거의 모든 게임 코드가 초능력 클래스와 커플링된다.
    - 외부 시스템이 변경되면 초능력 클래스가 깨질 가능성이 높다.
    - 모든 초능력 클래스가 지켜야 할 불변식(invariant)을 정의하기 어렵다.
- __해결__
    1. 프로그래머가 사용할 **원시명령 집합** 을 제공한다. 이때 원시명령을 protected 메서드로 만들어 모든 하위 클래스에 쉽게 접근할 수 있도록 한다. 이는 이들 함수가 **하위 클래스용이라는 것** 을 구분할 수 있다.
    2. 원시명령 준비가 끝나면, 이를 사용할 공간을 제공해야 한다. 이를 위해 하위 클래스가 구현해야 하는 **샌드박스 메서드** 를 순수 가상 메서드로 만들어 protected에 둔다.
    - 새로운 클래스 구현은 다음과 같이 한다.
        1. 상위 클래스를 상속 받는 새로운 클래스를 만든다.
        2. 샌드박스 메서드인 activate()를 오버라이드한다.
        3. 상위 클래스가 제공하는 protected 메서드를 호출하여 activate()를 구현한다.
    - 상위 클래스가 제공하는 기능을 최대한 고수준 형태로 만듦으로써 *코드 중복 문제* 를 해결할 수 있다. 리펙토링 _풀업(pull up)_ 기법 사용한다.
    - 커플링을 한 곳으로 몰아서 *커플링 문제* 를 해결했다.
    - __하위 클래스 샌드박스 패턴을 스면 클래스 상속 구조가 얇게 퍼진다.__
## 패턴
- **상위 클래스** 는 추상 **샌드박스 메서드** 와 여러 **제공 기능(provided operation)** 을 정의한다.
- 제공 기능은 *protected* 로 만들어져 **하위 클래스용** 이라는 것을 분명히 한다. 각 하위 클래스는 제공 기능을 이용해 샌드박스 메서드를 구현한다.
### 언제 쓸 것인가?
- 클래스 하나에 하위 클래스가 많이 있다.
- 상위 클래스는 하위 클래스가 필요하는 기능을 전부 제공할 수 있다.
- 하위 클래스 행동 중에 겹치는 것이 많아, 이를 하위 클래스끼리 쉽게 공유하고 싶다.
- 하위 클래스들 사이의 커플링 및 하위 클래스와 나머지 코드와의 커플링을 최소화하고 싶다.
### 주의사항
- 상속은 상위 클래스에 코드가 계속 쌓이는 **버블업 효과** 때문에 부정적으로 생각된다. 특히 이 패턴에서는 그럴 여지가 많다.
- 상위 클래스가 하위 클래스, 하위 클래스에서 접근해야 하는 모든 시스템과 커플링된다. *깨지기 쉬운 상위 클래스(fragile base class)* 문제에 빠지게 된다.
- 커플링 대부분이 상위 클래스에 몰려 있기 때문에 **하위 클래스를 나머지 코드와 깔끔하게 분리할 수 있다** 는 *장점* 이 있다. 즉, 많은 코드가 격리되어 있어 유지보수하기 쉽다.
- 만약 상위 클래스 코드가 스파게티 덩어리가 되어간다면 __제공 기능 일부를 별도 클래스로 뽑아내 책임을 나눠 갖게 할 수도 있다.__ _컴포넌트 패턴(14장) 참고._
### 예제 코드
- 코드가 단순히 사운드, 파티클 이펙트, 모션 조합만으로 되어 있다면 하위 클래스 샌드박스 패턴을 사용할 *필요가 없다.*
- 대신, 초능력 클래스에서는 정해진 동작만 하도록 activate()를 구현해두고, 초능력별로 다른 사운드 ID, 파티클 타입, 움직임을 사용하게 만들면 된다. __그러나 모든 초능력이 본질적으로 동작은 같으면서 데이터가 다를 때만 가능하다.__
- **데이터 주도 방식** 을 사용하는 것이 좋지만, 기능이 복잡해 데이터로 정의하는 게 코드로 구현하는 것보다 더 어렵다면 데이터 주도 방식이 맞지 않을 수 있다.
## 디자인 결정
### 어떤 기능을 제공해야 하나?
- 제공 기능이 많을수록 하위 클래스는 외부 시스템과 적게 커플링되겠지만 상위 클래스와는 __더 많이__ 커플링된다. __ 하위 클래스에 있던 커플링을 상위 클래스로 옮겨놓는 셈이다.__
- 커플링을 상위 클래스로 옮김으로써 커플링을 한곳에 모아둘 수 있다는 *장점* 이 있지만 __상위 클래스는 커지고 유지보수하기 어려워진다.__
#### 일반적인 원칙
- 제공 기능을 몇 안 되는 하위 클래스에서만 사용한다면 별 이득이 없다. 이들 특수한 하위 클래스에서 __외부 시스템에 직접 접근하는 것이 더 간단하고 명확할 수 있다.__
- 다른 시스템의 함수를 호출할 때에도 그 함수가 상태를 변경하지 않는다면 크게 문제가 되지 않는다. **외부 시스템을 변경하는 함수** 를 호출한다면, 눈에 더 잘 들어오는 __상위 클래스의 제공 기능으로 옮겨주는 게 나을 수 있다.__
- 제공 기능이 단순히 외부 시스템으로 호출을 넘겨주는 일밖에 하지 않는다면 있어봐야 좋을 게 없다. __하위 클래스에서 외부 메서드를 직접 호출하는 게 더 깔끔할 수 있다.__ 다만, 단순히 포워딩만 하는 메서드도 하위 클래스에 **특정 상태를 숨길 수 있다는 장점이 있다.**
### 메서드를 직접 제공할 것인가? 이를 담고 있는 객체를 통해서 할 것인가?
- 이 패턴은 상위 클래스의 메서드가 많이 늘어난다는 단점이 있다.
- 해결
    - 이들 메서드 일부를 다른 클래스로 옮긴다.
    - 상위 클래스의 제공 기능에서는 이들 객체를 반환하기만 하면 된다.
- 제공 기능을 보조 클래스로 옮기면 다음과 같은 **이점** 이 있다.
    - 상위 클래스의 메서드 개수를 줄일 수 있다.
    - 보조 클래스에 있는 코드가 유지보수하기 더 쉬운 편이다.
    - 상위 클래스와 다른 시스템과의 커플링을 낮출 수 있다.
### 상위 클래스는 필요한 객체를 어떻게 얻는가?
#### 상위 클래스의 생성자로 받기
- 하위 클래스 생성자가 인수로 받아야 한다는 문제가 발생한다. __원치 않게 모든 하위 클래스에 상위 클래스의 상태가 노출된다.__
- 유지보수에 좋지 않다.
#### 2단계 초기화
- 생성자는 매개변수를 받지 않고 그냥 객체를 생성한 뒤, 상위 클래스 메서드를 따로 실행해 필요한 데이터를 제공한다.
- 까먹지 않고 init()를 호출해야 한다는 문제가 있다.
- 해결
    - 객체 생성 과정 전체를 한 함수로 캡슐화하면 해결할 수 있다.
    - 셍성자를 private에 두고 friend 클래스를 잘 활용하면 캡슐화할 수 있다.
#### 정적 객체로 만들기
- 상태 객체가 하나만 필요하다면(싱글턴) 상태를 상위 클래스의 **private 정적** 멤버 변수로 만들 수 있다.
- 여전히 초기화는 필요하지만 인스턴스마다 하지 않고 초능력 클래스에서 한 번만 초기화하면 된다.
- 이 방식은 어떤 상태가 굉장히 많은 객체에 공유되기 때문에 **싱글턴의 문제가 따라온다는 점** 을 유의해야 한다. private로 캡슐화하기 때문에 전역적으로 보이지 않지만, 코드를 이해아기가 전보다 어려워진다.
- 메모리 사용량을 줄일 수 있다.
```
class Superpower
{
private:
  static ParticleSystem* particles_;
public:
  static void init(ParticleSystem* particles)
  {
    particles_ = particles;
  }
};
```
#### 서비스 중개자 이용하기
- 앞에서는 초기화 부담을 외부 코드에 넘기고 있다.
- *서비스 중개자 패턴(16장)* 을 사용하여 해결한다.
```
class Superpower
{
protected:
  void spawnParticles(ParticleType type, int count)
  {
    ParticleSysyem& particles = Locator::getParticles();
    particles.spawn(type, count);
  }
}
```
## 관련자료
- 업데이트 메서드 패턴(10장)에서 업데이트 메서드는 흔히 샌드박스 메서드이기도 하다.
- 이와 상반된 패턴이 템플릿 메서드 패턴이다.(p237 참고)
- 이 패턴을 퍼사드 패턴의 일종으로 볼 수도 있다.
- [X] [하위 클래스 샌드박스 패턴 구현](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter12)

# Chapter 13. 타입 객체
- 의도: 클래스 하나를 인스턴스별로 다른 객체형으로 표현할 수 있게 만들어, 새로운 클래스들을 유연하게 만들 수 있게 한다.
- 동기
    - 모든 몬스터에게 체력 값과 공격 문구(attack string) 속성이 있다.
    - 기획자는 *몬스터 종족(breed)* 을 다양하게 만들고 싶어 한다.
- 전형적인 OOP 방식 단점
    - 하위 클래스가 너무 많다.
    - 종족을 추가할 때마다 코드를 추가하고 컴파일해야 한다.
- **해결**
    - 몬스터마다 종족에 대한 정보를 둔다. 상속받지 않고 Monster 객체가 Breed 객체를 참고하게 한다. 이때 Breed 클래스는 본질적으로 몬스터 *타입* 을 정의한다.
    - **장점**: 코드 수정 없이 새로운 타입을 정의할 수 있다.
## 패턴
- **타입 객체(type object)** 클래스와 **타입 사용 객체(typed object)** 클래스를 정의한다.
- 모든 타입 객체 인스턴스는 논리적으로 다른 타입을 의미한다.
- *타입 사용 객체*는 자신의 타입을 나타내는 **타입 객체를 참조한다.**
- 장점: 코드 수정 없이 새로운 타입을 정의할 수 있다.
#### 방법
- 인스턴스별로 다른 데이터는 **타입 사용 객체 인스턴스** 에 저장하고, 개념적으로 같은 타입끼리 공유하는 데이터나 동작은 **타입 객체** 에 저장한다.
- 같은 타입 객체를 참조하는 타입 사용 객체는 같은 타입인 것처럼 동작한다.
### 언제 쓸 것인가?
- 다양한 *종류* 를 정의해야 하는데 개발 언어의 타입 시스템이 유연하지 않아 코드로 표현하기 어려울 때
- 나중에 어떤 타입이 필요할지 알 수 없을 때
- 컴파일이나 코드 변경 없이 새로운 타입을 추가하거나 타입을 변경하고 싶을 때
### 주의사항
- 패턴의 핵심: 표현력은 떨어져도 훨씬 유연한 데이터로 타입을 표현
- 타입을 코드가 아닌 데이터로 표현하면서 잃는 것도 있다.
#### 타입 객체를 직접 관리해야 한다
- 각각의 클래스를 정의하는 데이터는 컴파일될 때 자동으로 실행 파일의 *정적 메모리 영역* 에 들어가 동작한다.
- 몬스터 인스턴스뿐만 아니라 **타입 객체도 직접 관리해야 한다.** 또한, 몬스터 인스턴스 생성 시 알맞은 종족 객체 레퍼런스로 초기화하는 것도 마찬가지다.
- __컴파일러가 해주던 일을 직접 구현해야 한다.__
#### 타입별로 동작을 표현하기가 더 어렵다
- 타입 객체로 종속적인 데이터를 정의하기 쉽지만 **타입 종속적인 동작을 정의하기는 어렵다.**
- __해결__
    1. 미리 동작 코드를 여러 개 정의해놓은 뒤에 타입 객체 데이터에서 이 중 하나를 *선택* 하는 것이다. 예를 들어, 타입 객체가 함수 포인터를 저장하게 한다.
    2. *바이트코드 패턴(11장)* 과 *인터프리터 패턴* 을 이용하면 동작을 표현하는 객체를 만들 수 있다. 파일에서 데이터를 읽어 앞에 패턴으로 자료구조를 만들면 동작 정의를 __코드에서 데이터로 완전히 옮길 수 있다.__
### 예제 코드
- Monster 클래스 생성자는 Breed 객체를 레퍼런스로 받는다.
#### 생성자 함수를 통해 타입 객체를 좀 더 타입 같이 만들기
- 기존 방식은 메모리를 먼저 할당한 후에 그 메모리 영역에 클래스를 할당하는 것과 다를 바 없다. OOP 언어는 이런 식으로 객체를 만들지 않는다.
- **해결**
    - **팩토리 메서드 패턴** 을 사용한다. 클래스의 생성자 함수를 호출해 클래스가 알아서 새로운 인스턴스를 생성하게 한다.
```
// 이전 코드 몬스터 생성
Monster* monster = new Monster(someBreed);
```
```
// 수정 후 몬스터 생성
Monster* monster = someBreed.newMonster();
```
- __이렇게 하는 이유(p248)__
    - 객체 생성 과정을 제어하고 싶을 때, *커스텀 할당자* 나 *객체 풀 패턴(19장)* 을 이용해 객체가 메모리 어디에 생성될지를 제어한다. __생성자 함수를 정의하면 이런 로직을 둘 곳이 생긴다.__
    - new가 아니라 newMonster 함수를 호출하면 Monster 클래스에 초기화 제어권을 넘겨주기 전에 *메모리 풀* 이나 *커스텀 힙* 에서 메모리를 가져올 수 있다. 몬스터를 생성할 수 있는 유일한 곳인 Breed 클래스 안에 이런 로직을 둠으로써, 모든 몬스터가 정해놓은 메모리를 관리 루틴에 따라 강제할 수 있다.
#### 상속으로 데이터 공유하기
- 여러 종족이 송속 값을 공유할 수 있도록 만든다. 그러나 언어의 상속 기능이 아닌 타입 객체끼리 상속할 수 있는 시스템을 **직접 구현한다.**
- 구현 방법
    1. 속성 값을 요청받을 때마다 동적으로 위임하는 방식
        - 장점: 특정 속성 값을 더 이상 오버라이드하지 않거나 상속받지 않도록 런타임에 바뀔 때 좋다.
        - **단점**: 메모리를 더 차지하고, 속성 값을 반환할 때마다 상위 객체를 확인하느라 *더 느리다.*
    2. **카피다운(copy-down)** 위임 방식(객체가 생성될 때 상속 값을 하위 타입으로 복사하는 방식)
        - 장점: 상위 객체 포인터를 들고 있지 않아도 된다. 깔끔하고 빠르다.
## 디자인 결정
### 타입 객체를 숨길 것인가? 노출할 것인가?
#### 타입 객체를 캡슐화하면
- 타입 객체 패턴의 복잡성이 나머지 다른 코드에는 드러나지 않는다.
- 타입 사용 객체는 타입 객체로부터 동작을 선택적으로 오버라이드할 수 있다.
- 타입 객체 메서드를 전부 포워딩해야 한다.
#### 타입 객체를 노출하면
- 타입 사용 클래스 인스턴스를 통하지 않고도 외부에서 타입 객체에 접근할 수 있다.
- __타입 객체가 공개 API의 일부가 된다.__ 유지보수하기 힘들다.
### 타입 사용 객체를 어떻게 생성할 것인가?
#### 객체를 생성한 뒤 타입 객체를 넘겨주는 경우
- 외부 코드에서 메모리 할당을 제어할 수 있다.
#### 타입 객체의 생성자 함수를 호출하는 경우
- 타입 객체에서 메모리 할당을 제어한다.
### 타입을 바꿀 수 있는가?
#### 타입을 바꿀 수 없다면
- 코드 구현하고 이해하기가 더 쉽다.
- 디버깅하기 쉽다.
#### 타입을 바꿀 수 있다면
- 객체 생성 횟수가 줄어든다. __타입 객체 포인터 값만 바꾸면 된다.__
- __가정을 깨지 않도록 주의해야 한다.__ 새로운 타입의 요구사항을 맞추기 위한 검증 코드가 필요할 수 있다.
### 상속을 어떻게 지원할 것인가?
#### 상속 없음
- 단순하다.
- 중복 작업을 해야 할 수도 있다.
#### 단일 상속
- 그나마 단순하다.
- 속성 값을 얻는 데 오래 걸린다.
#### 다중 상속
- 거의 모든 데이터 중복을 피할 수 있다.
- 복잡하다.
## 관련 자료
- *프로토타입 패턴(5장)* 은 같은 문제를 다른 방식으로 접근하고 있다.
- 타입 객체 패턴은 *경량 패턴(3장)* 과 비슷하다. 경량 패턴의 목표는 메모리 절약이고 타입 객체 패턴은 조직화와 유연성에 더 집중한다.
- 타입 객체 패턴은 *상태 패턴(7장)* 과 비슷한 점이 많다. 타입 객체를 교체할 수 있다면, 타입 객체가 상태 패턴 역할도 겸한다고 볼 수 있다.
- [X] [타입 객체 패턴 예제](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter13)

# Chapter 14. 컴포넌트
- 의도: 한 개체가 여러 분야를 서로 커플링 없이 다룰 수 있게 한다.
- 클래스에 한 가지 기능을 하는 클래스의 인스턴스를 갖게 한다.
- 컴포넌트 클래스들은 디커플링되어 있다. 서로 통신이 **필요한** 컴포넌트만으로 결합을 제한할 수 있다.
- 컴포넌트를 재사용할 수 있다. 상속은 단순한 코드를 재사용하는 용도로는 번거로울 때가 많다.
- 컴포넌트는 객체를 위한 *플러그 앤 플레이* 라고 볼 수 있다.
## 패턴
- 여러 분야를 다루는 하나의 객체를 분야별로 격리하기 위해, **각각의 코드를 별도의 컴포넌트 클래스에 둔다.** 이제 개체 클래스는 단순히 이들 *컴포넌트들의 컨테이너* 역할만 한다.
### 언제 쓸 것인가?
- 게임 개체를 정의하는 핵심 클래스에서
- 한 클래스에서 여러 분야를 건드리고 있어서 커플링하고 싶을 때
- 클래스가 거대해졌을 때
- 여러 다른 기능을 공유하는 다양한 객체를 정이하고 싶은데, 상속으로 원하는 부분만 골라서 재사용하지 못 할 때
### 주의사항
- 클래스 하나에 코드를 모아놨을 때보다 더 복잡해질 수 있다. 컴포넌트끼리 통신하기도 더 어렵고, 컴포넌트를 메모리 어디에 둘지 제어하는 것도 더 복잡하다. 코드베이스 규모가 크면 복잡성에서 오는 손해보다 __디커플링과 컴포넌트를 통한 코드 재사용에서 얻는 이득이 더 클 수 있다.__
- 무엇이든 하려면 한 단계를 거쳐야 할 때가 많다. 성능이 민감한 *내부 루프 코드* 에서 이런 식으로 포인터를 따라가다 보면 성능이 떨어질 수 있다. 그러나 성능이나 캐시 일관성을 향상해줄 때도 많다.
- 패턴 적용 전에 아직 있지도 않은 문제에 대한 해결책을 __오버엔지니어링하려는 건 아닌지 주의해야 한다.__
### 예제 코드
#### 분야별로 나누기
- Bjorn 클래스의 역할
    1. 자신을 정의하는 컴포넌트 집합을 관리한다.
    2. 컴포넌트들이 공유하는 상태를 들고 있다.
- 아직 **추상화** 하지 않았다.
#### 추상화(오토-비외른)
- 어떤 클래스라도 IuputComponent 추상 인터페이스만 구현하면 입력 컴포넌트가 될 수 있다.
- update()는 가상 메서드로 바뀌면서 *속도는 조금 느려졌다*
- __객체를 생성할 때 다른 컴포넌트와 연결할 수 있다.__
```
// 입력 컴포넌트 전달
Bjorn* bjorn = new Bjorn(new PlayerInputComponent());

// 데모 모드용
Bjorn* bjorn = new Bjorn(new DemoInputComponent());
```
#### 게임 객체 클래스로 변경
- 별도 클래스 없이도 *팩토리 메서드 패턴* 을 사용하여 객체를 만들 수 있다.
```
// 비외른 객체 생성 함수
GameObject* createBjorn()
{
  return new GameObject(
  new PlayerInputComponent(),
  new BjornPhysicsComponent(),
  new BjornGraphicsComponent());
}
```
## 디자인 결정
### 어떤 컴포넌트 집합이 필요한가?
게임 장르와 필요에 따라 다르다. 게임 코드가 크고 복잡할 수록 컴포넌트를 더 세분화해야 한다.
### 객체는 컴포넌트를 어떻게 얻는가?
#### 객체가 필요한 컴포넌트를 알아서 생성할 때
- 객체는 항상 필요한 컴포넌트를 가지게 된다.
- __객체를 변경하기가 어렵다.__ 하드 코딩해놓으면 이 패턴의 유연성을 잃게 된다.
#### 외부 코드에서 컴포넌트를 제공할 때
- 객체가 훨씬 유연해진다.
- 객체를 구체 컴포넌트 자료형으로부터 디커플링할 수 있다. 상속 받은 객체는 컴포넌트의 *인터페이스* 만 알기 때문에 구조를 캡슐화하기 더 좋다.
### 컴포넌트들끼리는 어떻게 통신할 것인가?
아래 방식은 서로 **배타적이지 않기** 때문에 여러 방식을 동시에 지원해야 할 것이다.
#### 컨테이너 객체의 상태를 변경하는 방식
- 컴포넌트들은 서로 디커플링 상태를 유지한다.
- 컴포넌트들이 공유하는 정보를 컨테이너 객체에 전부 넣어야 한다.
- 컴포넌트끼리 암시적으로 통신하다 보니 컴포넌트 __실행 순서에 의존하게 된다.__
#### 컴포넌트가 서로 참조하는 방식
- 간단하고 빠르다.
- __두 컴포넌트가 강하게 결합된다.__
#### 메시지를 전달하는 방식
- 컨테이너 객체에 간단한 메시징 시스템을 만든 뒤에, 각 컴포넌트들이 서로에게 정보를 뿌리게(broadcast) 할 수 있다.
- 메시지를 보내면, 컨테이너는 자신에게 있는 모든 컴포넌트에 이를 전파한다. 컨테이너 객체가 중재자에 해당한다. 처음 메시지를 보낸 컨포넌트도 포함되며, 피드백 루프에 빠지지 않도록 주의해야 한다. *이벤트 큐 패턴(15장)*
```
// 예시 코드
// 모든 컴포넌트가 상속받아야 하는 기본 인터페이스
class Component {
public:
 virtual ~Component() {}
 virtual void receive(int message) = 0;
};

// 컨테이너 객체
class ContainerObject {
private:
 static const int MAX_COMPONENTS = 10;
 Component* components_[MAX_COMPONENTS];
public:
 void send(int message) {
  for(int i = 0; i < MAX_COMPONENTS; ++i) {
   if(components_[i] != nullptr) {
    components_[i]->receive(message);
   }
  }
 }
};
```
- 특징
    - 하위 컴포넌트들은 디커플링된다.
    - 컨테이너 객체는 단순하다.
### 정리
- 상태 공유 방식: 기본적인 정보를 공유하기에 좋다. (ex. 위치, 크기)
- 참조 공유 방식: 서로 별개이나 가깝게 연관된 객체를 공유하기에 좋다. (ex. 애니메이션과 렌더링, 사용자 입력과 AI, 물리와 충돌)
- 메시징 방식: 호출하고 나서 신경 안 써도 되는 **사소한** 통신에 쓰기 좋다. (ex. 물리 컴포넌트가 충돌을 전파하면 오디오 컴포넌트가 이를 받아서 소리를 낸다.)
## 관련자료
- 컴포넌트 패턴은 전략 패턴과 비슷하다. 두 패턴 모두 객체의 동작 일부를 별도의 하위 객체에 위임한다. 다만 전략 객체는 *상태가 없는(stateless)* 경우가 대부분이다.
- [X] [컴포넌트 패턴 예제](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter14)

# Chapter 15. 이벤트 큐
- 의도: 메시지나 이벤트를 보내는 시점과 처리하는 시점을 디커플링한다.
## 이벤트 큐의 일반적인 특징
### GUI 이벤트 루프
- 애플리케이션이 원할 때 이벤트를 가져온다. 이벤트는 큐를 통해 OS로부터 애플리케이션으로 전달된다.
### 중앙 이벤트 버스
- 게임에서는 자체 이벤트 큐를 만들어 **중추 통신 시스템** 으로 활용하는 경우가 많다. (중앙, 전역, 메인)
- __게임 시스템들이 디커플링 상태를 유지한 채로 서로 고수준 통신을 하고 싶을 때 이를 사용한다.__
- 중앙 큐를 만들면 어느 게임 시스템에서도 큐에 이벤트를 보낼 수 있다. [AI 분야 흑판 시스템](http://goo.gl/hGn2M1)와 유사하다.
### 사운드 예제
```
// 사운드를 출력하는 API를 제공하는 오디오 엔진
class Audio {
public:
 static void playSound(SoundId id, int volume) {
  ResourceId resource = loadSound(id);
  int chnnel = findOpenChannel();
  if (channel == -1) return;
  startSound(resourcem channel, volume);
 }
}
```
```
// 메뉴 선택 시 소리
class Menu {
public:
 void onSelect(int index) {
  Audio::playSound(SOUND_BLOOP, VOL_MAX);
 }
}
```
이 상태에서 메뉴를 옮겨다니다 보면 **화면이 몇 프레임 정도 멈출 때** 가 있다. 문제가 뭘까?
#### 문제 1: API는 오디오 엔진이 요청을 완전히 처리할 때까지 호출자를 블록(block)한다.
- playSound()는 *동기적(synchronous)* 이다.
- 문제: 같은 소리를 동시에 출력하면 두 배 크기로 소리나는 것처럼 들린다. 사운드 출력이 무시되거나 끊긴다.
- 해결: 전체 사운드 호출을 취합하고 우선순위에 따라 나열해야 한다.
#### 문제 2: 요청을 모아서 처리할 수가 없다.
 멀티코어 하드웨어에서 실행되면 동기화처리가 안 되기 때문에 문제가 생긴다.
#### 문제 3: 요청을 원치 않는 스레드에서 처리된다.
- 모든 문제의 원인은 **즉시성** 이 문제다.
- 해결: 요청을 받는 부분과 요청을 처리하는 부분을 분리한다.
## 패턴
- 큐는 요청이나 알림을 들어온 순서대로 저장한다.(**선입선출**)
- 알림을 보내는 곳: **요청을 큐에 넣은 뒤에 결과를 기다리지 않고 리턴한다.**
- 요청을 처리하는 곳: 큐에 들어 있는 요청을 **나중에 처리한다.** 요청은 그곳에서 직접 처리될 수도 있고, 다른 여러 곳으로 보내질 수도 있다.
- 요청을 보내는 쪽과 받는 쪽을 **코드뿐만 아니라 시간 측면에서도 디커플링한다.**
### 언제 쓸 것인가?
- 메시지를 보내는 **곳** 과 받는 곳을 분리하고 싶을 뿐이라면 *관찰자 패턴(4장)* 이나 *명령 패턴(2장)* 로 이를 처리할 수 있다.
- 메시지를 보내는 **시점** 과 받는 시점을 분리하고 싶을 때만 큐가 필요하다.
- 큐는 요청을 받는 쪽에서 제어권을 제공한다.
### 주의사항
이벤트 큐는 복잡하고 게임 구조에 전반적으로 영향을 미치는 경향이 있다. 그렇기 때문에 패턴을 어떻게 사용할지, 혹은 정말 쓸 것인지를 잘 생각해야 한다.
#### 중앙 이벤트 큐는 전역 변수와 같다
이 패턴에서는 중앙 이벤트 큐를 간단한 프로토콜로 깔끔하게 래핑하지만 그래도 전역이다 보니 관련 문제가 여전히 존재한다.
#### 월드 상태는 언제든 바뀔 수 있다
- 이벤트를 받았을 때는 **현재** 월드 상태가 **이벤트가 만들어진 당시** 상태와는 다를 수 있다는 점을 주의해야 한다.
- 동기적으로 처리되는 이벤트보다 큐에 들어가는 이벤트에는 데이터가 훨씬 많이 필요하다.
#### 피드백 루프에 빠질 수 있다
*모든 이벤트, 메시지 시스템* 은 다음과 같은 순환이 생기지 않도록 주의해야 한다.
1. A가 이벤트를 보낸다.
2. B가 이벤트를 받아 응답으로 다른 이벤트를 보낸다.
3. 이 이벤트가 우연찮게 A에서 처리해줘야 하는 작업이라 A가 이벤트를 받는다. 그에 대한 응답으로 다른 이벤트를 보낸다.
4. 2번으로 간다.
- 메시징 시스템이 *동기적* 이라면 스택 오버플로 크래시가 나기 때문에 순환을 금방 찾을 수 있지만, 큐 시스템이라면 *비동기적* 이다 보니 콜스택이 풀려서 계속 이벤트를 주고 받는데도 계속 실행된다.
- 해결: 이벤트를 처리하는 코드 내에서는 **이벤트를 보내지 않는 것이다.** 이벤트 시스템에 간단한 **디버깅용 로거** 를 집어넣는 것도 좋다.
### 예제 코드
#### 원형 버퍼
연결 리스트로 구현한다. [head, tail) p293 참고
#### 요청 취합하기
같은 요청을 병합한다.
```
void playSound(SoundId id, int volume)
{
	// 보류 중인 요청을 쭉 살펴본다.
	for (int i = head_; i != tail_; i = (i + 1) % MAX_PENDING) {
		if (pending_[i].id == id) {
			// 큰 값으로 덮어 쓴다.
			pending_[i].volume = max(volume, pending_[i].volume);
			// 이 요청은 큐에 넣지 않는다.
			return;
		}
	}
}
```
- 큐네 넣기 전에 취합하기 때문에 호출하는 쪽의 처리 부담이 늘어난다는 단점이 있다. 큐가 크면 느려지기 때문에 **요청을 처리할 때 취합하는 게 나을 수도 있다.** SoundId를 키로 하는 해시 테이블을 쓰면 상수 시간에 중복 여부를 확인할 수 있다.
- 큐에 넣은 요청이 실제로 처리될 때까지 걸리는 시간이 동작에 영향을 미칠 수 있다.
#### 멀티스레드
멀티코어 적용 조건
1. 사운드 요청 코드와 사운드 재생 코드가 분리되어 있다.
2. 양쪽 코드 사이에 마샬링(marshaling)을 제공하기 위한 큐가 있다.
3. 큐는 나머지 코드로부터 캡슐화되어 있다.
4. 큐가 동시에 수정되는 것만 막는다.
## 디자인 결정
많은 게임들은 이벤트 큐를 통신 구조의 핵심 요소로 사용한다.
### 큐에 무엇을 넣을 것인가?
#### 큐에 이벤트를 넣는 경우
- *이벤트* 혹은 *통지* 는 **이미** 발생한 사건을 표현한다. (ex. 몬스터가 죽었음)
- 이벤트를 큐에 넣으면 다른 객체가 비동기 관찰자 패턴(4장) 같은 방식으로 이벤트에 대해 반응할 수 있다.
- 복수 개의 리스너를 지원해야 할 때도 많다.
- 큐의 범위가 더 넓은 편이다. 리스너가 최대한 유연할 수 있도록, 큐를 더 **전역적으로** 노출하는 편이다.
#### 큐에 메시지를 넣는 경우
- *메시지* 혹은 *요청* 은 **나중에** 실행했으면 하는 행동을 표현한다. (ex. 사운드 틀기)
- 서비스에 비동기적으로 API를 호출하는 것과 비슷하다.
- 대부분은 리스너가 하나다.
### 누가 큐를 읽는가?
#### 싱글캐스트 큐
- 큐가 **어떤 클래스의 API 일부일 때** 적합하다.
- 큐는 밖에서는 보이지 않는 내부 구현이 된다.
- 큐가 더 캡슐화되어 있다.
- 리스너 간에 경쟁을 고민하지 않아도 된다.
#### 브로드캐스트 큐
- 대부분의 **이벤트 시스템** 이 이런 식이다.
- 모든 리스너가 이벤트를 볼 수 있다.
- 이벤트가 무시될 수 있다. 리스너가 하나도 없다면 누구도 이벤트를 볼 수 없다.
- 이벤트 필터링이 필요할 수 있다. 이벤트 개수 X 리스너 개수만큼 이벤트 핸들러가 자주 호출된다.
#### 작업 큐
- 브로드캐스트 큐와 비슷하게 리스너가 여러 개 있다. *차이점* 큐에 들어 있는 데이터가 리스너 중에서 **한 곳** 에만 간다는 점이다.
- 스레드 풀에 작업을 나눠줘야 할 때 일반적으로 사용하는 패턴이다.
- 작업을 분배해야 한다.
### 누가 큐에 값을 넣는가?
이벤트 큐 패턴은 일대일, 일대다, 다대일, 다대일 등 모든 읽기/쓰기 조합으로 사용할 수 있다.
#### 넣는 측이 하나라면
- 동기형 관찰자 패턴(4장)에 가까운 형태다.
- 어디에서 이벤트가 오는지 암시적으로 안다.
- 보통 리스너가 여러 개다.
#### 넣는 측이 여러 개라면
예제 코드에서 본 오디오 엔진이 예시다.
- *전역* 혹은 *중앙* 이벤트 버스도 이런 식으로 작동한다.
- 이벤트 순환을 주의해야 한다.
- 이벤트를 보낸 객체에 대한 레퍼런스를 이벤트에 추가해야 할 필요가 있을 수 있다.
### 큐에 들어간 객체의 생명 주기는 어떻게 관리할 것인가?
메시지는 스택에 들어가는 지역 변수이기만 해도 충분하다. 큐에서는 큐에다 메시지를 추가하는 함수 호출이 끝난 후에도 **메시지 객체가 유지되어야 한다.**
#### 소유권을 전달한다
메모리를 직접 관리하는 언어에서 전통적으로 사용하는 방식이다.
#### 소유권을 공유한다.
#### 큐가 소유권을 가진다.
큐는 미리 할당해놓은 메시지의 레퍼런스를 반환하고 보내는 쪽에서는 값을 채운다. 처리가 끝나면 받는 쪽에서 이 메시지를 참조한다. **객체 풀(19장)이 큐의 보조 기억장치(backing store)가 되는 셈이다.**
## 관련자료
- 이벤트 큐는 관찰 패턴(4장)의 비동기형이다.
- 이벤트 큐는 *메시지 큐, 발행자/구독자(pubsub)* 라고 부르기도 한다. p301 참고
- 상태 패턴(7장)과 유사한 유한 상태 기계(FSM)에서는 입력 값을 스트림으로 받는다. 서로 통신을 주고 받는 상태 기계가 여러 개 있고, 각자 입력을 보류하기 위해 소형 큐를 사용한다면, **계산 액터 모델** 을 만든 셈이 된다.
- [X] [이벤트 큐 예제 코드](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter15)

# Chapter 16. 서비스 중개자
- 의도: 서비스를 구현한 구체 클래스는 숨긴 채로 어디에서나 서비스에 접근할 수 있게 한다.
- 정적 클래스를 사용하거나 싱글턴을 사용하여 시스템에 접근하면, 시스템의 구체 클래스뿐만 아니라 접근 매커니즘까지 직접 참조하게 된다. 이것을 디커플링 하기 위해 사용하는 패턴이다.
## 패턴
*서비스* 는 여러 기능을 추상 인터페이스로 정의한다. 구체 *서비스 제공자* 는 서비스 인터페이스를 상속받아 구현한다. *서비스 중개자(service locator)* 는 제공자의 실제 자료형과 이를 등록하는 과정을 숨긴채 서비스 제공자를 찾아 서비스에 대한 **접근을 제공한다.**
- 이 패턴은 더 유연하고 더 설정하기 좋은 싱글턴 패턴이다.
### 언제 쓸 것인가?
- 접근해야 할 객체가 있다면 전역 매커니즘 대신, 필요한 **객체를 인수로** 넘겨줄 수는 없는지 부터 생각해야 한다. 그러나 이 방식은 불필요하거나 코드를 읽기 어렵게 하기도 한다. 로그나 메모리 관리 같은 시스템이 모듈의 공개 API에 포함되어 있어선 안 된다.
- 어떤 시스템은 본질적으로 하나뿐이다. 이런 환경적 특징을 가장 깊숙이 들어 있는 함수에 전달하는 건 복잡성만 늘리는 것이다.
### 주의사항
이 패턴에서는 __두 코드가 커플링되는 의존성을 런타임 시점까지 미루는 부분이 가장 어렵다.__ 유연성을 얻을 수 있지만, 코드만 봐서 어떤 의존성을 사용하는지 알기 어렵다.
#### 서비스가 실제로 등록되어 있어야 한다
싱글턴이나 정적 클래스와는 다르게, 서비스 중개자 패턴에서는 **서비스 객체를 등록** 해야 하기 때문에 필요한 객체가 없을 때를 대비해야 한다.
#### 서비스는 누가 자리를 가져다가 놓는지 모른다
전역에서 접근 가능하기 떄문에 모든 코드에서 서비스를 요청하고 접근할 수 있다. 즉, __서비스는 어느 환경에서나 문제없이 동작해야 한다.__ 서비스는 정확히 정해진 곳에서만 실행되는 것을 보장할 수 없기 때문이다. **특정 상황에서만 실행되어야 한다면** 이 패턴을 적용하지 않는 것이 안전하다.
### 예제 코드
*이벤트 큐(15장)* 에서 다룬 오디오 시스템 문제를 서비스 중개자를 통해 제공한다.
#### 단순한 중개자
- 의존성 주입: 특정 객체가 필요로 하는 의존 객체를 외부 코드에서 주입
```
// Locator, 의존성 주입 기법 사용
class Locator
{
private:
	static Audio* service_;
public:
	static Audio* getAudio() { return service_; } // 중개 역할
	static void provide(Audio* service) { service_ = service; }
};
```
```
// getAudio 함수의 서비스 인스턴스 반환
Audio* audio = Locator::getAudio();
audio->playSound(VERY_LOUD_BANG);
```
```
// Locator의 서비스 등록 방법
ConsoleAudio* audio = new ConsoleAudio();
Locator::provide(audio);
```
__꼭 서비스 중개자 패턴용으로 만들지 않은 기존 클래스에도 이 패턴을 적용할 수 있다.__
#### 널 서비스
서비스를 등록하기 전에 사용하려고 시도하면 **NULL을 반환한다.** 이때 호출하는 쪽에서 NULL 검사를 하지 않으면 크래시 된다. [시간적 결합(temporal coupling)](https://joyyir.github.io/the%20pragmatic%20programmer/the-pragmatic-programmer-28/#)
- **널 객체(Bull Object)** 디자인 패턴은 NULL을 반환해야 할 때, 대신 같은 인터페이스를 구현한 특수한 객체를 반환한다. 안전하게 작업을 진행할 수 있다. 널 서비스는 **의도적으로** 특정 서비스를 못 찾게 하고 싶을 때도 유용하다.
#### 로그 데코레이터
조건적으로 로그를 남기고 싶은 시스템이 서비스로 노출되어 있다면 GoF의 *데코레이터 패턴(장식자 패턴)* 으로 로그 문제를 해결할 수 있다.
- 실제 기능 요청은 내부에 있는 서비스에 전달하고, 대신 사운드가 호출될 때마다 로그를 남긴다.
- 널 서비스에 적용하면 사운드는 **비활성화** 해놓고 정상적으로 사운드가 활성화되었다면 어떤 사운드가 출력되었을지를 로그로 확인할 수 있다.
- [X] [서비스 중개자 예제 코드](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter16)
## 디자인 결정
구현은 다음과 같은 핵심적인 질문들을 고려해 다양하게 달라질 수 있다.
### 서비스는 어떻게 등록되는가?
#### 외부 코드에서 등록
예제 코드 방식이 이에 해당한다. 게임 프로젝트에서 가장 *일반적으로* 사용되는 방법이다.
- 빠르고 간단하다. getAudio 함수는 단순히 포인터만 반환하면 된다. 이런 함수는 컴파일러에서 **인라인** 시킬 수 있다.
- 서비스 제공자를 어떻게 만들지 제어할 수 있다.
- 게임 실행 도중에 서비스를 교체할 수 있다.
- 서비스 중개자가 외부 코드에 의존한다는 **단점** 이 있다. 초기화가 제대로 안 되어 있다면 크래시가 나거나 이상하게 서비스가 동작하지 않는다.
#### 컴파일할 때 바인딩
다음과 같은 방식으로 *전처리기 매크로* 를 이용해 컴파일할 때 등록한다.
```
class Locator
{
private:
#if DEBUG
	static DebugAudio service_;
#else
	static ReleaseAudio service_;
#endif
public:
	static Audio& getAudio() { return service_; }
};
```
- 빠르다. 모든 작업이 컴파일할 때 끝난다.
- 서비스는 항상 사용 가능하다.
- 서비스를 쉽게 **변경할 수 없다.** 재컴파일한 뒤에 게임을 다시 시작해야 변경 가능하다.
#### 런타임에 설정 값 읽기
서비스 제공자 설정 파일을 로딩한 뒤에, 리플렉션(reflection)으로 원하는 서비스 제공자 클래스 객체를 런타임에 생성한다.
- 다시 컴파일하지 않고도 서비스를 교체할 수 있다.
- 프로그래머가 아니어도 서비스를 바꿀 수 있다.
- 등록 과정을 코드에서 완전히 빼냈기 때문에 하나의 코드로 여러 설정을 동시에 지원할 수 있다. 기업형 웹 소프트웨어에서 이 방식을 많이 사용한다.
- 복잡하다. 파일을 로딩해서 파싱한 뒤에 서비스를 등록하는 설정 시스템을 만들어야 한다.
- 서비스 등록에 시간이 걸린다. 서비스 등록을 위해 *CPU 사이클* 을 낭비해야 한다.
### 서비스를 못 찾으면 어떻게 할 것인가?
#### 사용자가 알아서 처리하게 한다.
중개자는 서비스를 찾지 못하면 NULL을 반환한다.
- 실패했을 때 어떻게 처리할지를 사용자 쪽에서 정할 수 있다. 실패 결과를 호출하는 쪽으로 넘긴다.
- 서비스 사용자 쪽에서 실패를 처리해야 한다. 호출하는 쪽에서 항상 서비스를 찾았는지 **검사해야 한다.**
#### 게임을 멈춘다.
*단언문* 을 추가한다.
```
class Locator
{
public:
	static Audio& getAudio() 
	{ 
		Audio* service = NULL;
		// 서비스를 찾는 코드
		
		assert(service != NULL);
		return *service;
	}
};
```
- 사용자 측에서는 서비스가 없는 경우를 처리하지 않아도 된다. 서비스 사용자 측의 부담을 줄일 수 있다.
- 서비스를 찾지 못하면 게임이 중단된다. 문제가 생기면 고쳐지기 전까지 다른 팀원들이 **아무것도 할 수 없다.**
#### 널 서비스를 반환한다
- 외부 코드에서는 서비스가 없는 경우를 처리하지 않아도 된다.
- 서비스를 사용할 수 없을 때에도 게임을 계속할 수 있다. 단점은 의도치 않게 서비스를 찾지 못할 때에도 디버깅하기가 쉽지 않다는 점이다. 널 서비스가 사용될 때마다 *디버깅용 로그* 를 출력하게 하면 문제를 줄일 수 있다.
#### 결론
셋 중에서는 *단언문* 을 거는 형태가 가장 많이 사용된다. 규모가 큰 팀이라면 *널 서비스* 가 좋다.
### 서비스의 범위는 어떻게 잡을 것인가?
지금까지는 *어디에서나* 중개자를 통해서 서비스를 접근할 수 있다고 가정했다. 그러나 특정 클래스 및 하위 클래스에서만 접근을 제한할 수 있다.
#### 전역에서 접근 가능한 경우
- 전체 코드에서 같은 서비스를 쓰도록 한다.
- 언제 어디에서 서비스가 사용되는지를 제어할 수 없다.
#### 접근이 특정 클래스에 제한되면
- 커플링을 제어할 수 있다.
- 중복 작업을 해야 할 수 있다는 단점이 있다.
#### 결론
서비스가 게임의 특정 분야에 한정되어 있다면 하나의 클래스로 접근 범위를 좁히는 편이 좋다. 예를 들어 네트워크 접근 서비스는 온라인 클래스에서만 사용하게 하고, 로그 같은 서비스는 전역에 둔다.
