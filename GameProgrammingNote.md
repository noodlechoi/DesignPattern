# Chapter 1. 구조, 성능, 게임
## 1.1 소프트웨어 구조란?
  ### 좋은 소프트웨어 구조란?
  - 구조는 변경과 관련 있다.
  - 쉽게 변경할 수 있어야 한다.
  - __확장에는 열려있고, 변경에는 닫혀있어야 한다.__
  - __작업에 들어가기 전에 알아야 할 지식의 양을 줄이는 것이다.__
  ### 디커플링
  - 커플링: 한쪽 코드가 없으면 코드를 이해할 수 없는 상황
  - 두 코드를 디커플링하면, 각각을 따로 이해할 수 있다.
  - 어느 한 코드를 변경했을 때 다른 코드를 변경하지 않아도 된다.
## 1.2 비용은?
- 구조 유지에는 많은 노력이 필요하다.
- 확장 가능성을 제공하는 것은 예측을 했기 때문이다. 그러나 만든 모듈을 사용하지 못하면 작업할 코드만 늘어나는 일이 발생한다.
- '엔진'은 게임을 만들기 위해 존재한다.
## 1.3 성능과 속도
- 소프트웨어 구조와 추상화가 런타임 비용을 요구하여 게임 성능을 저하시킨다. 반례로는 C++ 템플릿이 있다.
- 성능은 가정에 기반한다. 최적화 기법은 구체적인 제한을 선호한다.
- 재밌는 게임을 최적화하는 것이 최적화된 게임을 재밌게 만드는 것보다 쉽다.
- 코드를 유연하게 유지하다가 기획이 확실해지면 다음 추상 계층을 제거해 성능을 높이는 방법도 있다.
## 1.4 나쁜 코드의 장점
- 버릴 코드를 적은 시간으로 작성할 수 있다. 단, 버릴 코드는 나중에 확실히 버릴 수 있게 해야 한다.
- 프로토타입용 코드를 다른 언어로 작성하여 반드시 코드를 재작성하도록 만들 수 있다.
## 1.5 균형 잡기
- 목표
  1. 구조 깔끔하게 만들기
  2. 실행 성능 최적화
  3. 개발 중인 기능 빠르게 구현
  - 정리: 장기적인 개발 속도, 게임 실행 속도, 단기적인 개발 속도
- 최적화 이후 코드가 고착되는 경향이 있다.
## 1.6 단순함
- 목표를 잡기 위한 제약을 완화하는 방법은 단순함이다.
- 자료구조와 알고리즘은 먼저 잡아놓고 방법을 찾아간다.
- 좋은 해결책이란 __필요 없는 코드를 최대한 빼는 것이다.__
## 1.7 정리
- 추상화와 디커플링을 잘 활용하면 코드를 점차 쉽고 빠르게 만들 수 있다. 하지만 고민 중인 코드에 유연함이 필요없다면 추상화와 디커플링을 적용하면 안 된다.
- 개발 내내 성능을 고민하고, 최적화에 맞게 설계해야 한다. 하지만 가정을 코드에 박는 저수준의 핵심 최적화는 가능하면 늦게 하라.
- 게임 기획 내용을 확인할 수 빠르게 개발하되, 코드를 엉망으로 하면 안 된다.
- 재밌는 걸 만들고 싶다면 만드는 데에서 재미를 느껴야 한다.

# Chapter 2. 명령
> 요청 자체를 캡슐화한다. 서로 다른 사용자(client)를 매개변수로 만들고, 요청을 대기시키거나 로깅하며, 되돌릴 수 있는 연산자를 지원한다. [Gof의 디자인 패턴, p311]
- __명령 패턴은 메소드 호출을 실체화(reify)한 것이다.__
- __명령 패턴은 콜백을 객체지향적으로 표현한 것이다.__
- _실체화_ 와 _일급(first-class)_: 어떤 개념을 변수에 저장하거나 함수에 전달할 수 있도록 데이터(객체)로 바꿀 수 있는 것
- 지속 자료구조(persistent data structure): 어떤 객체를 변경하면 원래 객체는 그대로 두고 새로운 객체를 반환한다. 명령 객체마다 명령 실핼 전에 객체를 참조하고 있다가, 실행을 취소할 때 객체를 이전 객체로 되돌려주면 된다.
- 클로저를 지원하는 언어에서는 명령 패턴에 함수를 사용하여 구현할 수 있다(p54).
- 클로저(closure): 일급 객체 함수의 개념을 이용하여 스코프에 묶인 변수를 바인딩 하기 위한 일종의 기술
- [x] [명령 패턴 예제](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter2)

# Chapter 3. 경량
> 공유를 통해 많은 수의 소립(fine-grained) 객체들을 효과적으로 지원한다.[Gof의 디자인 패턴, p265]
- 객체의 개수가 너무 많아서 가볍게 사용하고 싶을 때 사용한다.
- 객체의 데이터를 두 종류로 나눈다.
  1. __고유 상태(intrinsic state), 자유문맥(context-free)__: 공유 데이터
  2. __외부 상태(extrinsic state)__: 인스턴스별로 값이 다른 데이터
- 공유 객체가 명확하지 않은 경우 경량 패턴은 잘 드러나 보이지 않는다.
## 예제
- 주로 숲에서 수많은 나무를 구현할 때 사용되는 패턴이다.
- GPU로 보내는 데이터 양을 최소화하기 위해 공유 데이터를 딱 한 번만 보내야 한다. 이후, 값이 다른 데이터들을 전달하고, GPU에게 전체 나무 인스턴스를 그릴 때 공유 데이터를 사용하도록 하면 된다.
- Direct3D, OpenGL 모두 __인스턴스 렌더링 __ 을 지원한다.
-인스턴스 렌더링을 위해서 데이터 스크림 두 개가 필요하다.
  1. 공유 데이터
  2. 다르게 보이기 위해 필요한 매개변수들
- [x] [경량 패턴 예제 지형 정보](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter3)
## 성능
  - 지형 데이터를 포인터로 접근한다는 것은 __간접 조합(indirect lookup)__ 한다는 뜻이다. 이때 캐시 미스가 발생할 수 있어 성능이 떨어질 수 있다.
  - 객체의 메모리 배치에 따라 측정되는 속도가 달라질 수 있기 때문에 확신할 수는 없다.
  - 열거형을 선언해 많은 다중 선택문을 만들기 전에 경량 패턴을 고려해봐야 한다.
## 정리
- 예제에서 인스턴스를 미리 만들었지만 필요할 때 만드는 것이 낫다. 인스턴스를 요청 받았을 때, 이전에 만들어 놓은 것을 확인하면 된다. 객체를 생성할 때 기존 객체가 존재하는지 먼저 확인할 수 있도록 생성 코드를 인터페이스 밑으로 숨겨둬야 한다. 이런 방식으로 __생성자를 숨기는 방식__ 은 Gof 팩토리 메소드 패턴의 한 예이다.
- _상태 패턴(7장)_ 을 사용할 때, 상태 기계에서 상태 객체에 멤버 변수가 하나도 없는 경우가 있다. 이때, 경량 패턴을 적용하면 상태 인스턴스 하나를 여러 상태 기계에서 동시에 __재사용__ 할 수 있다.

# Chapter 4. 관찰자
> 객체 사이에 일 대 다의 의존 관계를 정의해두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지 받고 자동으로 업데이트될 수 있게 만든다.[Gof의 디자인 패턴, p382]
- MVC(Model-View-Contoller) 구조는 관찰자 패턴을 기반으로 한다.
- 관찰자 패턴을 적용하면 어떤 코드에서 흥미로운 일이 생겼을 때 누가 받든 상관없이 알림을 보낼 수 있다.
- 목적: 코드 간의 결합을 최소화
## 예제
- 특정 기능을 담당하는 코드는 항상 한 곳에 모아두는 게 좋다.
### 관찰자
- onNotify 함수에서 아무 매개변수나 상관없지만, 보통 __알림을 보내는 객체와 다른 구체적인 정보를 담은 일반적인 데이터__ 를 매개변수로 넘긴다.
### 대상
- 알림 메소드는 __관찰당하는 객체(subject)__ 가 호출한다.
  - 대상(주체) 두 가지 임무
    1. 관찰자 목록 들고 있기(배열로)
    2. 알림 보내기
- onNotify 함수 호출 시 관찰자 목록을 건드리지 못하게 하거나 동시에 변경하더라도 문제없도록 구현하면 안전하다. 또는, 관찰자 목록을 지역 변수에 복사한 값을 대신 순회하도록 한다.
### 물리 관찰
- 남은 작업
  1. 물리 엔진에 훅(hook)을 걸어 알림을 보낼 수 있게 하는 일
  2. 업적 시스템에서 알림을 받을 수 있도록 스스로를 등록하게 하는 일
- Subject 클래스를 상속 받는 대신 Physics 클래스가 Subject 인스턴스를 포함하게 만드는 것이 좋다. 이러면 물리 엔진 자체를 관찰하기 보다는, 별도의 낙하 이벤트 객체가 대상이 된다. 관찰자는 스스로 physics.entityFell().addObserver(this);로 등록한다.
- __관찰자 시스템__ 에서는 뭔가 관심 있는 일을 하는 객체를 관찰하지만, __이벤트 시스템__ 에서는 관심 있는 일 자체를 나타내는 객체를 관찰한다.
- [x] [관찰자 패턴 예제](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter4)
## 관찰자 패턴의 단점
- 대상이 관찰자 메소드를 직접 호출하기 때문에 모든 관찰자가 알림 메소드를 반환하기 전에는 다음 작업을 진행할 수 없다. 관찰자 중 하나라도 느리면 대상이 블록될 수도 있다.
- 이벤트에 동기적(synchronous)으로 반응한다면 최대한 빨리 작업을 끝내거나 다른 스레드에게 넘기거나 작업 큐를 활용해야 한다.
- 멀티스레드, 락(lock)과 함꼐 사용 시에 교착상태에 빠지지 않도록 주의해야 한다. 엔젠에서 멀티스레드를 많이 사용한다면, 이벤트 큐(15장)을 이용해 비동기적으로 상호작용하는 것이 좋다.
- 메모리 회수(reclaim)하다 보면 동적 할당이 오래 걸릴 수 있다.
## 관찰자 연결 리스트(p77)
- Observer에 상태를 조금 추가하여 대상에 포인터 컬렉션을 따로 두지 않고, 관찰자 객체가 연결 리스트의 노드가 된다. 대상은 관찰자 연결 리스트를 포인터로 가리킨다.
- __Subject가 관리해야할 관찰자 목록은 Observer 클래스 안에 있다.__
- 같은 대상을 관찰하는 관찰자끼리 알림 순서로 인한 __의존 관계가 있어서는 안 된다.__
- 리스트 자체를 노드로 활용하기 때문에 __관찰자는 한 번에 한 대상만 관찰할 수 있다는 한계가 있다.__
## 리스트 노드 풀(p80)
- 대상이 관찰자 연결 리스트를 들고 있지만, 노드가 관찰자 객체가 아닌 __관찰자와 다음으로 가는 포인터의 데이터를 가지고 있는 노드__ 를 만든다. 이 방법을 침습성(intrusive) 연결 리스트라고 부른다. 유연함은 떨어지지만 효율은 더 좋다.
- 여러 대상을 한번에 관찰할 수 있다.
- 동적 할당을 피하는 방법은 모든 노드가 같은 자료형에 같은 크기이기 때문에 객체 풀(19장)에 미리 할당하면 된다.
## 기술적인 문제
- __대상이 죽었을 때__ , 대상이 삭제되기 직전에 마지막으로 '사망' 알림을 보내면 된다.
- __관찰자를 제거할 때__ , 대상이 관찰자를 포인터로 알고 있기 때문에 더 어렵다. 아래 두 방법은 모두 관찰자가 자기가 관찰 중인 대상들의 목록을 관리해야 하기 때문에 __상호참조__ 가 생겨 복잡성이 늘어나는 단점이 있다.
  1. __관찰자가 삭제될 때 스스로를 등록 취소__ 한다. 관찰자의 소멸자에서 대상의 removeObserver()만 호출하면 된다.
  2. __자동으로 모든 대상으로부터 등록 취소하게 만든다.__
- __GC(garbage collector)__ 가 있는 언어에도 문제가 발생한다. 상태창을 보여주는 UI를 예시로 보면, UI가 보이지 않지만 캐릭터 관찰자 목록에서 여전히 상태창 UI를 참조하고 있기 때문에 GC가 수거해 가지 않는다. 또한, 눈에 보이지 않는 UI 요소를 업데이트하느라 CPU 클럭을 낭비한다. 이를 _사라진 리스너 문제(lapsed listener problem)_ 이라고 부른다.
## 유지보수 문제
- 코드가 명시적으로 커플링되어 있으면 어떤 메소드가 호출되는지 보면 되지만, 관찰자 목록을 통해 코드가 커플링되어 있다면 _런타임_ 에서 확인해봐야 한다.
- 코드를 이해하기 위해 양쪽 코드의 상호작용을 같이 확인해야 할 일이 많다면, 관찰자 패턴 대신 두 코드를 명시적으로 연결하는 것이 낫다.
- 반대로, 모듈 같은 서로 연관 없는 코드 덩어리들이 하나의 큰 덩어리가 되지 않으면서 서로 상호작용하기에는 관찰자 패턴을 사용하는 것이 좋다.
## 오늘날의 관찰자
- 상속은 무겁고 융통성이 없다. 한 클래스가 대상 인스턴스별 알림 메소드를 다르게 정의할 수 없다.
- 최근에는 메소드나 함수 레퍼런스만으로 관찰자를 만든다.
## 미래의 관찰자
- 데이터 흐름 프로그래밍(dataflow programming), [함수형 반응형 프로그래밍(functional reactive programing)](http://goo.gl/wkerWw)는 사운드 프로세싱이나 칩 설계 같은 제한적인 분야에서 성공을 거두었다.
- __데이터 바인딩__ 은 어떤 값이 변경되면 관련된 UI나 속성을 바꿔줘야 하는 귀찮은 작업을 알아서 해준다. 게임 핵심 코드에 적용하기에는 느리고 복잡하지만, UI같이 성능에 덜 민감한 부분에 사용할 수 있을 것이다.

# Chapter 5. 프로토타입
> 원형이 되는(prototypical) 인스턴스를 사용하여 생성할 객체의 종류를 명시하고, 이렇게 만든 견본을 복사해서 새로운 객체를 생성한다.[Gof의 디자인 패턴, p169]
- 프로토타입의 클래스뿐만 아니라 상태도 같이 __복제(clone)__ 한다.
- 상속 구조가 복잡하면 유지보수가 힘들기 때문에, 요즘은 개체 종류별로 클래스를 만들기보다는 _컴포넌트(14장)_ 나 _타입 객체(13장)_ 로 모델링하는 것을 선호한다
- 클래스가 전달 가능한 일급 자료형인 동적 자료형 언어에서는 문제를 훨씬 직접적으로 풀 수 있다.
- [X] [프로토타입 패턴 예제](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter5)
## 프로토타입 언어 패러다임
- 객체지향 프로그래밍(OOP)는 데이터와 코드를 묶어주는 객체를 직접 정의할 수 있게 한다.
- OOP는 상태와 동작을 함께 묶는다.
### 클래스 기반 언어
- 상태(필드)와 동작 사이에 분명한 구별이 있다.
- 상태는 __인스턴스__ 에 있고, 동작은 __클래스__ 에 들어 있다.
- 클래스는 자기 자신의 인스턴스 생성기(factory)다.
### 셀프(p94)
- 상태와 동작 사이에 구별이 없다. 무엇이든 객체에서 바로 찾을 수 있다.
- 상속 대신 __위임(delegation)__ 개념이 있다. 레퍼런스로된 상위 객체를 찾아본다. 찾아보고 없으면 상위 객체에 위임한다.
- 객체를 만들 때 프로토타입 패턴처럼 복제를 한다.
- 비슷한 객체를 여럿 만들려면 다음과 같이 한다.
  1. 객체 하나를 원하는 상태로 만든다. 시스템에서 제공하는 기본 Object 객체를 복제한 뒤에 필드와 메소드를 채워 넣는다.
  2. 원하는 만큼 복제한다.
- 복잡한 것을 사용자에게 넘겼기 때문에 사용하기 불편하다. 많은 게임에서 캐릭터 클래스, 적, 아이템 등을 명확하게 나누고 있는 점도 포함된다.
### 자바스크립트
- 자료형을 정의하는 객체로부터 new를 호출하는 생성자 함수를 통해 객체를 생성한다.
- 상태는 인스턴스 그 자체에 저장된다.
- 동작은 자료형이 같은 객체 모두가 공유하는 메소드 집합을 대표하는 별도 객체인 프로토타입에 저장되고 위임을 통해 간접 접근된다.
- 프로토타입기반 언어인 핵심인 __복제를 찾을 수 없다.__
## 데이터 모델링을 위한 프로토타입
- __JSON__ 을 사용해 프로토타입과 위임을 활용해 데이터를 재사용할 수 있다.
- 객체에 프로토타입 필드를 넣어서 중복을 제거할 수 있다.
- 추상 프로토타입을 따로 만들지 않아도 된다.

# Chapter 6. 싱글턴
> 오직 한 개의 클래스 인스턴스만을 갖도록 보장하고, 이에 대한 전역적인 접근점을 제공합니다.[Gof의 디자인 패턴, p181]
- 한 개의 클래스 인스턴스만 갖도록 한다. 그 인스턴스를 전역에서 접근할 수 있는 메소드를 제공한다.
- 생성자를 private으로 제한한다. 정적 메소드 instatnce는 싱글턴을 실제로 필요할 때까지 인스턴스 초기화를 미룬다.
- 장점
  - 인수로 주고 받지 않아도 어디서나 접근할 수 있다.
  - 한 번도 사용하지 않는다면 아예 인스턴스를 생성하지 않는다.
  - 런타임에 초기화된다.
  - 싱글턴을 상속할 수 있다. 싱글턴 상속 기법은 단위 테스트용 모의 객체(mock object)를 만들 때도 유용하다.
## 싱글턴 패턴의 문제
- 전역 변수는 코드 이해를 어렵게 한다.
  - 순수 함수: 전역 상태에 접근하거나 수정하지 않는 함수. 이해가 쉽고 컴파일러가 쉽게 최적화할 수 있다. 메모이제이션 기법을 사용할 수 있다.
- 전역 변수는 커플링을 조장한다.
- 전역 변수는 멀티스레딩 같은 동시성 프로그래밍에 알맞지 않다.
- 한 가지 기능만 사용하려고 해도 두 가지 기능을 사용해야 한다. 예를 들어 Log 클래스를 싱글턴으로 만들 때, 하나의 파일 안에 로그를 써야 한다.
- 게임에서 게으른 초기화가 적절하지 않다.
## 대안
- 가능하면 도우미 클래스에 있던 작동 코드를 모두 원래 클래스로 옮기는 것이 낫다. 객체가 스스로 챙기게 하는 것이 OOP다.
### 오직 한 개의 클래스 인스턴스만 갖도록 보장하기
- 인스턴스가 둘 이상 되는 순간 __단언문(assert)__ 에 걸린다.
- 단일 인스턴스는 보장하지만 클래스를 어떻게 사용할지에 대해 강제하지 않는다.
- __단점__: 싱글턴은 클래스 문법을 활용해 컴파일 시간에 단일 인스턴스를 보장하지만, 이 방식은 __런타임에 인스턴스 개수를 확인__ 한다.
### 인스턴스에 쉽게 접근하기
1. __넘겨주기__
    - __의존성 주입(dependency injection)__: 매개변수로 받아 사용하는 방식
    - 어떤 객체는 메소드 시그니처에 포함되지 않는다.
2. __상위 클래스로부터 얻기__
    - Log 인스턴스 얻는 방법
      1. GameObject가 Log 인스턴스를 정적으로 생성해 들고 있기
      2. Log 객체를 얻을 수 있는 초기화 함수 제공
      3. 서비스 중개자 패턴(16장) 사용
3. __이미 전역인 객체로부터 얻기__
    - 단점
      - 더 많은 코드가 전역 클래스에 커플링 된다.
      - 객체에 접근하기 위해서 전역 클래스에 대해 알아야 한다.
    - 해결
      - 넘겨주기 사용
      - 상위 클래스로부터 얻기를 통해 접근
4. __서비스 중개자로부터 얻기__
- [X] [싱글턴 패턴 예제](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter6)
### 싱글턴 패턴 대체 패턴
- 하위 클래스 샌드박스 패턴(12장), 서비스 중개자 패턴(16장)

# Chapter 7. 상태
> 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게 허가하는 패턴으로, 이렇게 하면 객체는 마치 자신의 클래스를 바꾸는 것처럼 보인다.[Gof의 디자인 패턴, p395]
## 유한 상태 기계(FSM)
- 오토마타 이론에서 나왔다.
- __요점__
  - 가질 수 있는 __'상태'__ 가 한정된다.
  - 한 번에 '한 가지' 상태만 될 수 있다.
  - __'입력'__ 이나 '이벤트'가 기계에 전달된다.
  - 각 상태에는 입력에 따라 다음 상태로 바뀌는 __'전이(transition)'__가 있다.
## 상태 패턴
- 때로는 if문만으로 충분하다. 그러나 Heroine 예제 정도라면 상태 패턴을 쓰는 것이 낫다.
1. 상태 인터페이스
    - __상태에 의존하는 모든 코드(다중 선택문에 있던 동작)을 인터페이스의 가상 메소드로 만든다.__ 예제에서는 handleInput()과 update()가 해당된다.
2. 상태별 클래스 만들기
3. 동작을 상태에 위임하기
    - Heroin 클래스에 자신의 현재 상태 객체 포인터를 추가한다. 상태를 바꾸려면 포인터에 다른 객체를 할당하면 된다.
### 전략 패턴, 타입 객체 패턴과의 차이
- 차이점은 의도에 있다.
- 전략 패턴: 주요 클래스를 일부 동작으로부터 __디커플링__ 하는 것이 목표다.
- 타입 객체 패턴: 같은 타입 객체의 레퍼런스를 __공유__ 함으로써 __여러__ 객체를 비슷하게 동작시키는 것이 목표다.
상태 패턴: 동작을 위임하는 객체를 __변경__ 함으로써 주요 클래스의 동작을 변경하는 것이 목표다.
## 상태 객체
1. 정적 객체
    - 상태 객체에 필드가 따로 없다면 가상 메소드 호출에 필요한 vtable 포인터만 있는 셈이다. 모든 인스턴스는 같기 때문에 인스턴스는 하나만 있으면 된다.(경량 패턴)
    - 정적 인스턴스는 원하는 곳에 둔다.
    - 필드가 없고 가상 메소드도 하나밖에 없다면 상태 클래스를 정적 함수로 바꿀 수 있다.
2. 상태 객체 만들기
    - 새로 상태를 할당했기 때문에 이전 상태를 해제해야 한다. this를 스스로 지우지 않도록 주의해야 한다.
## 입장과 퇴장
- 상태에서 그래픽까지 제어하는 것이 바람직하다.
- 새로운 상태로 교체됐을 때 입장 기능을 사용한다. 입장 기능 한곳에 코드를 모아둘 수 있다.
- 새로운 상태로 교체되기 직전에 퇴장 코드를 추가할 수도 있다.
## FSM 단점
- 미리 정해놓은 여러 상태와 현재 상태 하나, 하드코딩되어 있는 전이만 존재한다.
- 상태 기계를 인공지능 같은 복잡한 곳에 적용하기에 한계가 있다. __튜링 완전(Turing complete)하지조차 않다.__
### 병행 상태 기계
- 무엇을 하는가에 대한 상태 n개와 무엇을 들고 있는가에 대한 상태 m을 한 상태 기계에 욱여넣으면 __n*m__ 개 상태가 필요하다. 상태 기계를 둘로 나누면 __n+m__ 개 상태만 있으면 된다.
- 상태를 각각 참조한다. 상태에 위임할 때는 상태 기계 양쪽에 다 전달한다.
- 첫 번째 상태 기계에서 입력을 씹어서(consume) 다음 상태 기계까지 입력이 가지 않도록 할 수 있다.
- __단점__ : 어떤 상태 코드에서 다른 상태 기계의 상태가 무엇인지 검사하는 지저분한 코드를 만드는 일이 생길 수도 있다.
### 계층형 상태 기계
- 단순 상태 기계에서는 모든 상태마다 코드를 중복해서 넣어야 한다. 상속으로 여러 상태가 코드를 공유할 수 있다.
- 어떤 상태는 __상위 상태(superstate)__ 를 가질 수 있고, 그 경우 그 상태 자신은 __하위 상태(substate)__ 가 된다.
- 이번트가 들어올 때 하위 상태에서 처리하지 않으면 상위 상태로 넘어간다.
- 클래스를 사용하는 Gof식 상태 패턴을 쓰지 않는다면, 클래스에 상태를 하나만 두지 않고 상태 스택을 만들어 명시적으로 현재 상태의 상위 상태 연쇄를 모델링할 수도 있다.
### 푸시다운 오토마타
- FSM에는 __이력__ 개념이 없다는 문제가 있다.
- FSM은 이전 상태를 덮어쓴다면, 푸시다운 오토마타는 __상태 스택__ 을 사용한다.
## FSM 유용함
- 요즘 게임 AI는 행동 크리나 계획 시스템을 더 많이 쓰는 추세이기 때문에 FSM만으로는 한계가 있다.
- 다음과 같을 때 FSM을 사용하면 좋다.
    - 내부 상태에 따라 객체 동작이 바뀔 때
    - 이런 상태가 그다지 많지 않은 선택지로 분명하게 구분될 수 있을 때
    - 객체가 입력이나 이벤트에 따라 반응할 때
- [X] [상태 패턴 예제](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter7)
