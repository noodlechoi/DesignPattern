# Chapter 1. 구조, 성능, 게임
## 1.1 소프트웨어 구조란?
  ### 좋은 소프트웨어 구조란?
  - 구조는 변경과 관련 있다.
  - 쉽게 변경할 수 있어야 한다.
  - __확장에는 열려있고, 변경에는 닫혀있어야 한다.__
  - __작업에 들어가기 전에 알아야 할 지식의 양을 줄이는 것이다.__
  ### 디커플링
  - 커플링: 한쪽 코드가 없으면 코드를 이해할 수 없는 상황
  - 두 코드를 디커플링하면, 각각을 따로 이해할 수 있다.
  - 어느 한 코드를 변경했을 때 다른 코드를 변경하지 않아도 된다.
## 1.2 비용은?
- 구조 유지에는 많은 노력이 필요하다.
- 확장 가능성을 제공하는 것은 예측을 했기 때문이다. 그러나 만든 모듈을 사용하지 못하면 작업할 코드만 늘어나는 일이 발생한다.
- '엔진'은 게임을 만들기 위해 존재한다.
## 1.3 성능과 속도
- 소프트웨어 구조와 추상화가 런타임 비용을 요구하여 게임 성능을 저하시킨다. 반례로는 C++ 템플릿이 있다.
- 성능은 가정에 기반한다. 최적화 기법은 구체적인 제한을 선호한다.
- 재밌는 게임을 최적화하는 것이 최적화된 게임을 재밌게 만드는 것보다 쉽다.
- 코드를 유연하게 유지하다가 기획이 확실해지면 다음 추상 계층을 제거해 성능을 높이는 방법도 있다.
## 1.4 나쁜 코드의 장점
- 버릴 코드를 적은 시간으로 작성할 수 있다. 단, 버릴 코드는 나중에 확실히 버릴 수 있게 해야 한다.
- 프로토타입용 코드를 다른 언어로 작성하여 반드시 코드를 재작성하도록 만들 수 있다.
## 1.5 균형 잡기
- 목표
  1. 구조 깔끔하게 만들기
  2. 실행 성능 최적화
  3. 개발 중인 기능 빠르게 구현
  - 정리: 장기적인 개발 속도, 게임 실행 속도, 단기적인 개발 속도
- 최적화 이후 코드가 고착되는 경향이 있다.
## 1.6 단순함
- 목표를 잡기 위한 제약을 완화하는 방법은 단순함이다.
- 자료구조와 알고리즘은 먼저 잡아놓고 방법을 찾아간다.
- 좋은 해결책이란 __필요 없는 코드를 최대한 빼는 것이다.__
## 1.7 정리
- 추상화와 디커플링을 잘 활용하면 코드를 점차 쉽고 빠르게 만들 수 있다. 하지만 고민 중인 코드에 유연함이 필요없다면 추상화와 디커플링을 적용하면 안 된다.
- 개발 내내 성능을 고민하고, 최적화에 맞게 설계해야 한다. 하지만 가정을 코드에 박는 저수준의 핵심 최적화는 가능하면 늦게 하라.
- 게임 기획 내용을 확인할 수 빠르게 개발하되, 코드를 엉망으로 하면 안 된다.
- 재밌는 걸 만들고 싶다면 만드는 데에서 재미를 느껴야 한다.

# Chapter 2. 명령
> 요청 자체를 캡슐화한다. 서로 다른 사용자(client)를 매개변수로 만들고, 요청을 대기시키거나 로깅하며, 되돌릴 수 있는 연산자를 지원한다. [Gof의 디자인 패턴, p311]
- __명령 패턴은 메소드 호출을 실체화(reify)한 것이다.__
- __명령 패턴은 콜백을 객체지향적으로 표현한 것이다.__
- _실체화_ 와 _일급(first-class)_: 어떤 개념을 변수에 저장하거나 함수에 전달할 수 있도록 데이터(객체)로 바꿀 수 있는 것
- 지속 자료구조(persistent data structure): 어떤 객체를 변경하면 원래 객체는 그대로 두고 새로운 객체를 반환한다. 명령 객체마다 명령 실핼 전에 객체를 참조하고 있다가, 실행을 취소할 때 객체를 이전 객체로 되돌려주면 된다.
- 클로저를 지원하는 언어에서는 명령 패턴에 함수를 사용하여 구현할 수 있다(p54).
- 클로저(closure): 일급 객체 함수의 개념을 이용하여 스코프에 묶인 변수를 바인딩 하기 위한 일종의 기술
- [x] [명령 패턴 예제](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter2)

# Chapter 3. 경량
> 공유를 통해 많은 수의 소립(fine-grained) 객체들을 효과적으로 지원한다.[Gof의 디자인 패턴, p265]
- 객체의 개수가 너무 많아서 가볍게 사용하고 싶을 때 사용한다.
- 객체의 데이터를 두 종류로 나눈다.
  1. __고유 상태(intrinsic state), 자유문맥(context-free)__: 공유 데이터
  2. __외부 상태(extrinsic state)__: 인스턴스별로 값이 다른 데이터
- 공유 객체가 명확하지 않은 경우 경량 패턴은 잘 드러나 보이지 않는다.
## 예제
- 주로 숲에서 수많은 나무를 구현할 때 사용되는 패턴이다.
- GPU로 보내는 데이터 양을 최소화하기 위해 공유 데이터를 딱 한 번만 보내야 한다. 이후, 값이 다른 데이터들을 전달하고, GPU에게 전체 나무 인스턴스를 그릴 때 공유 데이터를 사용하도록 하면 된다.
- Direct3D, OpenGL 모두 __인스턴스 렌더링 __ 을 지원한다.
-인스턴스 렌더링을 위해서 데이터 스크림 두 개가 필요하다.
  1. 공유 데이터
  2. 다르게 보이기 위해 필요한 매개변수들
- [x] [경량 패턴 예제 지형 정보](https://github.com/noodlechoi/DesignPattern/tree/main/PracticeGame/Chapter3)
## 성능
  - 지형 데이터를 포인터로 접근한다는 것은 __간접 조합(indirect lookup)__ 한다는 뜻이다. 이때 캐시 미스가 발생할 수 있어 성능이 떨어질 수 있다.
  - 객체의 메모리 배치에 따라 측정되는 속도가 달라질 수 있기 때문에 확신할 수는 없다.
  - 열거형을 선언해 많은 다중 선택문을 만들기 전에 경량 패턴을 고려해봐야 한다.
## 정리
- 예제에서 인스턴스를 미리 만들었지만 필요할 때 만드는 것이 낫다. 인스턴스를 요청 받았을 때, 이전에 만들어 놓은 것을 확인하면 된다. 객체를 생성할 때 기존 객체가 존재하는지 먼저 확인할 수 있도록 생성 코드를 인터페이스 밑으로 숨겨둬야 한다. 이런 방식으로 __생성자를 숨기는 방식__ 은 Gof 팩토리 메소드 패턴의 한 예이다.
- _상태 패턴(7장)_ 을 사용할 때, 상태 기계에서 상태 객체에 멤버 변수가 하나도 없는 경우가 있다. 이때, 경량 패턴을 적용하면 상태 인스턴스 하나를 여러 상태 기계에서 동시에 __재사용__ 할 수 있다.

# Chapter 4. 관찰자
> 객체 사이에 일 대 다의 의존 관계를 정의해두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지 받고 자동으로 업데이트될 수 있게 만든다.[Gof의 디자인 패턴, p382]
- MVC(Model-View-Contoller) 구조는 관찰자 패턴을 기반으로 한다.
- 특정 기능을 담당하는 코드는 항상 한 곳에 모아두는 게 좋다.
- 관찰자 패턴을 적용하면 어떤 코드에서 흥미로운 일이 생겼을 때 누가 받든 상관없이 알림을 보낼 수 있다.
